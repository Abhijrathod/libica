
/*
             Common Public License Version 0.5

             THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF
             THIS COMMON PUBLIC LICENSE ("AGREEMENT"). ANY USE,
             REPRODUCTION OR DISTRIBUTION OF THE PROGRAM CONSTITUTES
             RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.

             1. DEFINITIONS

             "Contribution" means:
                   a) in the case of the initial Contributor, the
                   initial code and documentation distributed under
                   this Agreement, and

                   b) in the case of each subsequent Contributor:
                   i) changes to the Program, and
                   ii) additions to the Program;

                   where such changes and/or additions to the Program
                   originate from and are distributed by that
                   particular Contributor. A Contribution 'originates'
                   from a Contributor if it was added to the Program
                   by such Contributor itself or anyone acting on such
                   Contributor's behalf. Contributions do not include
                   additions to the Program which: (i) are separate
                   modules of software distributed in conjunction with
                   the Program under their own license agreement, and
                   (ii) are not derivative works of the Program.


             "Contributor" means any person or entity that distributes
             the Program.

             "Licensed Patents " mean patent claims licensable by a
             Contributor which are necessarily infringed by the use or
             sale of its Contribution alone or when combined with the
             Program.

             "Program" means the Contributions distributed in
             accordance with this Agreement.

             "Recipient" means anyone who receives the Program under
             this Agreement, including all Contributors.

             2. GRANT OF RIGHTS

                   a) Subject to the terms of this Agreement, each
                   Contributor hereby grants Recipient a
                   non-exclusive, worldwide, royalty-free copyright
                   license to reproduce, prepare derivative works of,
                   publicly display, publicly perform, distribute and
                   sublicense the Contribution of such Contributor, if
                   any, and such derivative works, in source code and
                   object code form.

                   b) Subject to the terms of this Agreement, each
                   Contributor hereby grants Recipient a
                   non-exclusive, worldwide, royalty-free patent
                   license under Licensed Patents to make, use, sell,
                   offer to sell, import and otherwise transfer the
                   Contribution of such Contributor, if any, in source
                   code and object code form. This patent license
                   shall apply to the combination of the Contribution
                   and the Program if, at the time the Contribution is
                   added by the Contributor, such addition of the
                   Contribution causes such combination to be covered
                   by the Licensed Patents. The patent license shall
                   not apply to any other combinations which include
                   the Contribution. No hardware per se is licensed
                   hereunder.

                   c) Recipient understands that although each
                   Contributor grants the licenses to its
                   Contributions set forth herein, no assurances are
                   provided by any Contributor that the Program does
                   not infringe the patent or other intellectual
                   property rights of any other entity. Each
                   Contributor disclaims any liability to Recipient
                   for claims brought by any other entity based on
                   infringement of intellectual property rights or
                   otherwise. As a condition to exercising the rights
                   and licenses granted hereunder, each Recipient
                   hereby assumes sole responsibility to secure any
                   other intellectual property rights needed, if any.

                   For example, if a third party patent license is
                   required to allow Recipient to distribute the
                   Program, it is Recipient's responsibility to
                   acquire that license before distributing the
                   Program.

                   d) Each Contributor represents that to its
                   knowledge it has sufficient copyright rights in its
                   Contribution, if any, to grant the copyright
                   license set forth in this Agreement.

             3. REQUIREMENTS

             A Contributor may choose to distribute the Program in
             object code form under its own license agreement, provided
             that:
                   a) it complies with the terms and conditions of
                   this Agreement; and

                   b) its license agreement:
                   i) effectively disclaims on behalf of all
                   Contributors all warranties and conditions, express
                   and implied, including warranties or conditions of
                   title and non-infringement, and implied warranties
                   or conditions of merchantability and fitness for a
                   particular purpose;

                   ii) effectively excludes on behalf of all
                   Contributors all liability for damages, including
                   direct, indirect, special, incidental and
                   consequential damages, such as lost profits;

                   iii) states that any provisions which differ from
                   this Agreement are offered by that Contributor
                   alone and not by any other party; and

                   iv) states that source code for the Program is
                   available from such Contributor, and informs
                   licensees how to obtain it in a reasonable manner
                   on or through a medium customarily used for
                   software exchange.

             When the Program is made available in source code form:
                   a) it must be made available under this Agreement;
                   and
                   b) a copy of this Agreement must be included with
                   each copy of the Program.

             Contributors may not remove or alter any copyright notices
             contained within the Program.

             Each Contributor must identify itself as the originator of
             its Contribution, if any, in a manner that reasonably
             allows subsequent Recipients to identify the originator of
             the Contribution.


             4. COMMERCIAL DISTRIBUTION

             Commercial distributors of software may accept certain
             responsibilities with respect to end users, business
             partners and the like. While this license is intended to
             facilitate the commercial use of the Program, the
             Contributor who includes the Program in a commercial
             product offering should do so in a manner which does not
             create potential liability for other Contributors.
             Therefore, if a Contributor includes the Program in a
             commercial product offering, such Contributor ("Commercial
             Contributor") hereby agrees to defend and indemnify every
             other Contributor ("Indemnified Contributor") against any
             losses, damages and costs (collectively "Losses") arising
             from claims, lawsuits and other legal actions brought by a
             third party against the Indemnified Contributor to the
             extent caused by the acts or omissions of such Commercial
             Contributor in connection with its distribution of the
             Program in a commercial product offering. The obligations
             in this section do not apply to any claims or Losses
             relating to any actual or alleged intellectual property
             infringement. In order to qualify, an Indemnified
             Contributor must: a) promptly notify the Commercial
             Contributor in writing of such claim, and b) allow the
             Commercial Contributor to control, and cooperate with the
             Commercial Contributor in, the defense and any related
             settlement negotiations. The Indemnified Contributor may
             participate in any such claim at its own expense.


             For example, a Contributor might include the Program in a
             commercial product offering, Product X. That Contributor
             is then a Commercial Contributor. If that Commercial
             Contributor then makes performance claims, or offers
             warranties related to Product X, those performance claims
             and warranties are such Commercial Contributor's
             responsibility alone. Under this section, the Commercial
             Contributor would have to defend claims against the other
             Contributors related to those performance claims and
             warranties, and if a court requires any other Contributor
             to pay any damages as a result, the Commercial Contributor
             must pay those damages.


             5. NO WARRANTY

             EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE
             PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT
             WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR
             IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR
             CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR
             FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is solely
             responsible for determining the appropriateness of using
             and distributing the Program and assumes all risks
             associated with its exercise of rights under this
             Agreement, including but not limited to the risks and
             costs of program errors, compliance with applicable laws,
             damage to or loss of data, programs or equipment, and
             unavailability or interruption of operations.

             6. DISCLAIMER OF LIABILITY
             EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER
             RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY
             FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
             OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION
             LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF
             LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
             (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
             OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE
             OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE
             POSSIBILITY OF SUCH DAMAGES.

             7. GENERAL

             If any provision of this Agreement is invalid or
             unenforceable under applicable law, it shall not affect
             the validity or enforceability of the remainder of the
             terms of this Agreement, and without further action by the
             parties hereto, such provision shall be reformed to the
             minimum extent necessary to make such provision valid and
             enforceable.


             If Recipient institutes patent litigation against a
             Contributor with respect to a patent applicable to
             software (including a cross-claim or counterclaim in a
             lawsuit), then any patent licenses granted by that
             Contributor to such Recipient under this Agreement shall
             terminate as of the date such litigation is filed. In
             addition, If Recipient institutes patent litigation
             against any entity (including a cross-claim or
             counterclaim in a lawsuit) alleging that the Program
             itself (excluding combinations of the Program with other
             software or hardware) infringes such Recipient's
             patent(s), then such Recipient's rights granted under
             Section 2(b) shall terminate as of the date such
             litigation is filed.

             All Recipient's rights under this Agreement shall
             terminate if it fails to comply with any of the material
             terms or conditions of this Agreement and does not cure
             such failure in a reasonable period of time after becoming
             aware of such noncompliance. If all Recipient's rights
             under this Agreement terminate, Recipient agrees to cease
             use and distribution of the Program as soon as reasonably
             practicable. However, Recipient's obligations under this
             Agreement and any licenses granted by Recipient relating
             to the Program shall continue and survive.

             Everyone is permitted to copy and distribute copies of
             this Agreement, but in order to avoid inconsistency the
             Agreement is copyrighted and may only be modified in the
             following manner. The Agreement Steward reserves the right
             to publish new versions (including revisions) of this
             Agreement from time to time. No one other than the
             Agreement Steward has the right to modify this Agreement.

             IBM is the initial Agreement Steward. IBM may assign the
             responsibility to serve as the Agreement Steward to a
             suitable separate entity. Each new version of the
             Agreement will be given a distinguishing version number.
             The Program (including Contributions) may always be
             distributed subject to the version of the Agreement under
             which it was received. In addition, after a new version of
             the Agreement is published, Contributor may elect to
             distribute the Program (including its Contributions) under
             the new version. Except as expressly stated in Sections
             2(a) and 2(b) above, Recipient receives no rights or
             licenses to the intellectual property of any Contributor
             under this Agreement, whether expressly, by implication,
             estoppel or otherwise. All rights in the Program not
             expressly granted under this Agreement are reserved.


             This Agreement is governed by the laws of the State of New
             York and the intellectual property laws of the United
             States of America. No party to this Agreement will bring a
             legal action under this Agreement more than one year after
             the cause of action arose. Each party waives its rights to
             a jury trial in any resulting litigation.



*/

/* (C) COPYRIGHT International Business Machines Corp. 2001          */


/*********************************************************************/
/*                                                                   */
/* Module Name: icalinux.c                                           */
/*                                                                   */
/* Descriptive Name: Main IBM Crypographic Accelerator (ICA) library */
/*                   routines. These routines provide the API's      */
/*                   between the user's application and the ICA      */
/*                   device driver.                                  */
/*                                                                   */
/*-------------------------------------------------------------------*/
/*                                                                   */
/* IBM CONFIDENTIAL                                                  */
/* Object Code Only (OCO) source materials                           */
/* xxxxxxx                                                           */
/* (C) Copyright IBM Corporation, 2000                               */
/* The source code for this program is not published or              */
/* otherwise divested of its trade secrets, irrespective of          */
/* what has been deposited with the U.S. Copyright Office.           */
/*                                                                   */
/*-------------------------------------------------------------------*/
/*                                                                   */
/* Version 001, Release 000, Level 000                               */
/*                                                                   */
/* Author: jgrimm@us.ibm.com                                         */
/*                                                                   */
/* Description:                                                      */
/*                                                                   */
/*  This file contains the following subroutines.  See the           */
/*  routine prologs for descriptions.                                */
/*                                                                   */
/*      icaGetAdapterMask                                            */
/*      icaGetAdapterID                                              */
/*      icaGetVPD                                                    */
/*      icaOpenAdapter                                               */
/*      icaCloseAdapter                                              */
/*      icaRsaModExpo                                                */
/*      icaRsaCrt                                                    */
/*      icaDesEncrypt                                                */
/*      icaDesDecrypt                                                */
/*      icaTDesEncrypt                                               */
/*      icaTDesDecrypt                                               */
/*      icaDesMac                                                    */
/*      icaTDesMac                                                   */
/*      icaSha1                                                      */
/*      icaRandomNumberGenerate                                      */
/*                                                                   */
/*-------------------------------------------------------------------*/
/*                                                                   */
/* Additional DES and RSA software subroutines for S390              */
/*      icaDesSW                                                     */
/*      icaTDesSW                                                    */
/*      icaRsaModExpoSW                                              */
/*      icaRsaCrtSW                                                  */
/*      icaRsaModMultSW                                              */
/*                                                                   */
/*      ModExpoSW                                                    */
/*      ModMulSW                                                     */
/*      ModSW                                                        */
/*      AddSW                                                        */
/*      ModSubSW                                                     */
/*      MulSW                                                        */
/*                                                                   */
/* Authors:                                                          */
/*      Amuche Chukudebelu, Robert Burroughs, and Eric Rossman       */
/*                                                                   */
/*-------------------------------------------------------------------*/
/* Change history:                                                   */
/* Date        Init  Description                                     */
/* ----------  ----  ------------------------------------------------*/
/* 2001-01-25  JAG   Create file                                     */
/* 2001-08-29  AC    Added icaDesSW and icaTDesSW                    */
/* 2001-08-29  RHB   Added SW RSA/Multiprecision Routines            */
/* 2001-11-27  RHB   Fixed icaRsaCrtSw to handle 2048 bit            */
/* 2002-01-11  RHB   Fixed Des routines                              */
/* 2002-11-11  RHB   Added crypto assist instruction support         */
/* 2004-05-31  EDR   Support new /udev char device files, and use new*/
/*                   ioctl for z90crypt, replacing deprecated ioctl  */
/* 2004-06-01  EDR   Fix SHA1 function on 64-bit s390x platform      */
/* 2004-09-22  EDR   Update signal handling                          */
/* 2004-11-30  EDR   CPACF instruction testing should occur only at  */
/*                   library initialization for S/390                */
/* 2005-01-31  EDR   Signal handling corrected to properly unblock   */
/*                   signal prior to setting handler.                */
/* 2005-05-16  EDR   Clean up the formatting in several sections of  */
/*                   code and fix a few minor bugs.                  */
/* 2005-05-16  EDR   Add error handling around calls to CPACF        */
/*                   instructions.                                   */
/*********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <linux/config.h>

#ifdef __s390__
#ifndef _LINUX_S390_
#define _LINUX_S390_ 1
#endif
#ifdef __s390x__
#ifndef _LINUX_S390X_
#define _LINUX_S390X_ 1
#endif
#endif
#endif

#ifdef _LINUX_S390_
#define __USE_GNU
#include <string.h>
#endif
#include <fcntl.h>
#include <sys/types.h>
#include <sys/ioctl.h>

#include <endian.h>
#include <byteswap.h>

#include <errno.h>

#include <linux/types.h>
#ifdef _LINUX_S390_
#include "z90crypt.h"
#ifndef __BIG_ENDIAN__
#define __BIG_ENDIAN__ 1
#endif
#include "sha.h"
#else
#include <linux/icaioctl.h>
#endif

#include "ica_api.h"
#include "ica_err.h"

#ifdef _LINUX_S390_
#include <unistd.h>
#include <signal.h>
#include <setjmp.h>
#include <openssl/des.h>
#include <openssl/bn.h>
#endif

#ifdef _LINUX_S390_
#define DEFAULT_CRYPT_DEVICE "/udev/z90crypt"
#define DEFAULT2_CRYPT_DEVICE "/dev/z90crypt"
#else
#define DEFAULT_CRYPT_DEVICE "/udev/ica"
#define DEFAULT2_CRYPT_DEVICE "/dev/ica"
#endif

#if __BYTE_ORDER == __BIG_ENDIAN
/* The host byte order is the same as network byte order,
   so these functions are all just identity.  */
# define betoh32(x)	(x)
# define betoh64(x)	(x)
# define htobe32(x)	(x)
# define htobe64(x)	(x)
#else
# if __BYTE_ORDER == __LITTLE_ENDIAN
#  define betoh32(x)	__bswap_32 (x)
#  define betoh64(x)	__bswap_64 (x)
#  define htobe32(x)	__bswap_32 (x)
#  define htobe64(x)	__bswap_64 (x)
# endif
#endif

enum arbitrary {
  MAXBASESIZE=120,
  MAXMINORSIZE=8
};

#ifdef _LINUX_S390_
/*--------------------------------------------------------------------------*
 * Structures and #defines for z routines                                   *
 *--------------------------------------------------------------------------*/
enum _sizelimits {
  ICA_SHA_DATALENGTH = 20,
  ICA_SHA_BLOCKLENGTH = 64,
};

typedef struct ica_rsa_modexpo ica_rsa_modexpo_t;
typedef struct ica_rsa_modexpo ica_rsa_modmult_t;
typedef struct ica_rsa_modexpo_crt ica_rsa_modexpo_crt_t;

typedef unsigned char ica_des_vector_t[8];
typedef unsigned char ica_des_key_t[8];

enum _ica_mode_des {
  DEVICA_MODE_DES_CBC = 0,
  DEVICA_MODE_DES_ECB = 1
};

enum _ica_direction_des {
  DEVICA_DIR_DES_ENCRYPT = 0,
  DEVICA_DIR_DES_DECRYPT = 1
};

typedef struct _ica_des {
  unsigned int      mode;
  unsigned int      direction;
  unsigned char    *inputdata;
  unsigned int      inputdatalength;
  ica_des_vector_t *iv;
  ica_des_key_t    *keys;
  unsigned char    *outputdata;
  int              outputdatalength;
} ica_des_t;

typedef unsigned char ica_sha1_result_t[ICA_SHA_DATALENGTH];

typedef struct _ica_sha1 {
  unsigned char     *inputdata;
  unsigned int       inputdatalength;
  ica_sha1_result_t *outputdata;
  ica_sha1_result_t *initialh;
} ica_sha1_t;

/*--------------------------------------------------------------------------*
 * Function prototypes for z routines                                       *
 *--------------------------------------------------------------------------*/
unsigned int icaRsaModExpoSW(ica_rsa_modexpo_t *);
unsigned int icaRsaCrtSW(ica_rsa_modexpo_crt_t *);
unsigned int icaRsaModMultSW(ica_rsa_modmult_t *);
unsigned int ModExpoSW(int, char *, int, char *, int, char *, int *, char *, BN_CTX *);
unsigned int ModMulSW(int, char *, int, char *, int, char *, int *, char *, BN_CTX *);
unsigned int ModSW(int, char *, int, char *, int *, char *, BN_CTX *);
unsigned int AddSW(int, char *, int, char *, int *, char *, BN_CTX *);
unsigned int ModSubSW(int, char *, int, char *, int, char *, int *, char *, BN_CTX *);
unsigned int MulSW(int, char *, int, char *, int *, char *, BN_CTX *);
unsigned int icaDesSW(unsigned int,
	              unsigned int,
                      unsigned int,
	              unsigned char *,
	              ICA_DES_VECTOR *,
	              ICA_KEY_DES_SINGLE *,
	              unsigned int *,
	              unsigned char *);
unsigned int icaTDesSW(unsigned int,
                       unsigned int,
                       unsigned int,
		       unsigned char *,
                       ICA_DES_VECTOR *,
                       ICA_KEY_DES_TRIPLE *,
                       unsigned int *,
                       unsigned char *);
int icaSha1SW(ica_sha1_t *,
              unsigned int,
              unsigned long long *,
              unsigned char *);

int zDes(ica_des_t *, unsigned int);
int zSha1(ica_sha1_t *, unsigned int, unsigned long long *);

static unsigned char SHACONST[20] = {
 0x67,0x45,0x23,0x01,0xef,0xcd,0xab,0x89,
 0x98,0xba,0xdc,0xfe,0x10,0x32,0x54,0x76,
 0xc3,0xd2,0xe1,0xf0
};

#define EXCEPTION_RV 20

static volatile int sha1_switch = 0;
static volatile int des_switch = 0;
static volatile int cpacf_checked = 0;

static jmp_buf envq;
static void sigill_handler(int sig)
{
	longjmp(envq, EXCEPTION_RV);
}

static int querySHA1(void)
{
	unsigned char mask[16];

	asm volatile
#ifdef _LINUX_S390X_
	("	slgr	0,0		\n"	// R0 = 0;
	 "	lgr	1,%0		\n"	// R1 = mask
	 "	.long	0xb93e0004	\n"	// KIMD
	 :
	 :"d" (mask)
	 :"cc","0","1","4");
#else
	("	slr	0,0		\n"	// R0 = 0;
	 "	lr	1,%0		\n"	// R1 = mask
	 "	.long	0xb93e0004	\n"	// KIMD
	 :
	 :"d" (mask)
	 :"cc","0","1","4");
#endif
	if (mask[0] & 0x40)
		sha1_switch = 1;
	return sha1_switch;
}

static int queryDES(void)
{
	unsigned char mask[16];

	asm volatile
#ifdef _LINUX_S390X_
	("	slgr	0,0		\n"	// R0 = 0;
	 "	lgr	1,%0		\n"	// R1 = mask
	 "	.long	0xb92e0062	\n"	// KM
	 :
	 :"d" (mask)
	 :"cc","0","1","2","6");
#else
	("	slr	0,0		\n"	// R0 = 0;
	 "	lr	1,%0		\n"	// R1 = mask
	 "	.long	0xb92e0062	\n"	// KM
	 :
	 :"d" (mask)
	 :"cc","0","1","2","6");
#endif
	if (mask[0] & 40)
		des_switch = 1;
	return des_switch;
}

/*********************************************************************/
/*         r0 = fc                                                   */
/*         r1 = pIK                                                  */
/*         r4 = pO                                                   */
/*         r6 = pI                                                   */
/*         r7 = len                                                  */
/*           KMC                                                     */
/*         until cc != 3                                             */
/*********************************************************************/
static int KMC(unsigned long fc,	// function code
	       unsigned char *pIK,	// ICV followed by key
	       unsigned char *pO,	// output address
	       unsigned char *pI,	// input address
	       unsigned long len)	// input length
{
	register int cc = 0;
	asm volatile
#ifdef _LINUX_S390X_
	("	lgr	0,%1		\n"	// R0 = fc
	 "	lgr	1,%2		\n"	// R1 = pIK
	 "	lgr	4,%3		\n"	// R4 = pO
	 "	lgr	6,%4		\n"	// R6 = pI
	 "	lgr	7,%5		\n"	// R7 = len
	 "0:	.long	0xb92f0046	\n"	// KMC
	 "	brc	1,0b		\n"	// keep going while cc=3
	 "	ipm	%0		\n"	// condition code as uint
	 "	srl	%0,28		\n"	// cc = condition code
	 :"=d"(cc)
	 :"d"(fc),"d"(pIK),"d"(pO),"d"(pI),"d"(len)
	 :"cc","0","1","4","6","7");
#else
	("	lr	0,%1		\n"	// R0 = fc
	 "	lr	1,%2		\n"	// R1 = pIK
	 "	lr	4,%3		\n"	// R4 = pO
	 "	lr	6,%4		\n"	// R6 = pI
	 "	lr	7,%5		\n"	// R7 = len
	 "0:	.long	0xb92f0046	\n"	// KMC
	 "	brc	1,0b		\n"	// keep going while cc=3
	 "	ipm	%0		\n"	// condition code as uint
	 "	srl	%0,28		\n"	// cc = condition code
	 :"=d"(cc)
	 :"d"(fc),"d"(pIK),"d"(pO),"d"(pI),"d"(len)
	 :"cc","0","1","4","6","7");
#endif

	return cc;
} // end KMC

/*********************************************************************/
/*         r0 = fc                                                   */
/*         r1 = pK                                                   */
/*         r4 = pO                                                   */
/*         r6 = pI                                                   */
/*         r7 = len                                                  */
/*           KM                                                      */
/*         until cc != 3                                             */
/*********************************************************************/
static int KM(unsigned long fc,		// function code
	      unsigned char *pK,	// key
	      unsigned char *pO,	// output address
	      unsigned char *pI,	// input address
	      unsigned long len)	// input length
{
	register int cc = 0;

	asm volatile
#ifdef _LINUX_S390X_
	("	lgr	0,%1		\n"	// R0 = fc
	 "	lgr	1,%2		\n"	// R1 = pK
	 "	lgr	4,%3		\n"	// R4 = pO
	 "	lgr	6,%4		\n"	// R6 = pI
	 "	lgr	7,%5		\n"	// R7 = len
	 "0:	.long	0xb92e0046	\n"	// KM
	 "	brc	1,0b		\n"	// keep going while cc=3
	 "	ipm	%0		\n"	// condition code as uint
	 "	srl	%0,28		\n"	// cc = condition code
	 :"=d"(cc)
	 :"d"(fc),"d"(pK),"d"(pO),"d"(pI),"d"(len)
	 :"cc","0","1","4","6","7");
#else
	("	lr	0,%1		\n"	// R0 = fc
	 "	lr	1,%2		\n"	// R1 = pK
	 "	lr	4,%3		\n"	// R4 = pO
	 "	lr	6,%4		\n"	// R6 = pI
	 "	lr	7,%5		\n"	// R7 = len
	 "0:	.long	0xb92e0046	\n"	// KM
	 "	brc	1,0b		\n"	// keep going while cc=3
	 "	ipm	%0		\n"	// condition code as uint
	 "	srl	%0,28		\n"	// cc = condition code
	 :"=d"(cc)
	 :"d"(fc),"d"(pK),"d"(pO),"d"(pI),"d"(len)
	 :"cc","0","1","4","6","7");
#endif

	return cc;
} // end KM

/*********************************************************************/
/*         r0 = 0x01                                                 */
/*         r1 = digest_p                                             */
/*         r6 = msgP                                                 */
/*         r7 = msgL                                                 */
/*           KIMD (6)                                                */
/*         until cc != 3                                             */
/*********************************************************************/
static int KIMD(unsigned char *digest_p,
		unsigned char *msgP,
		unsigned long msgL)
{
	register int cc = 0;

	asm volatile
#ifdef _LINUX_S390X_
	("	slgr	0,0		\n"	// R0 = 0;
	 "	lghi	0,1		\n"	// R0 = 0x01
	 "	lgr	1,%1		\n"	// R1 = digest_p
	 "	lgr	6,%2		\n"	// R6 = message_p
	 "	lgr	7,%3		\n"	// R7 = messageLen
	 "0:	.long	0xb93e0006	\n"	// KIMD
	 "1:	brc	1,0b		\n"	// keep going while cc=3
	 "	ipm	%0		\n"	// condition code as uint
	 "	srl	%0,28		\n"	// cc = condition code
	 :"=d"(cc)
	 :"d" (digest_p),"d" (msgP),"d" (msgL)
	 :"cc","0","1","6","7");
#else
	("	slr	0,0		\n"	// R0 = 0;
	 "	lhi	0,1		\n"	// R0 = 0x01
	 "	lr	1,%1		\n"	// R1 = digest_p
	 "	lr	6,%2		\n"	// R6 = message_p
	 "	lr	7,%3		\n"	// R7 = messageLen
	 "0:	.long	0xb93e0006	\n"	// KIMD
	 "1:	brc	1,0b		\n"	// keep going while cc=3
	 "	ipm	%0		\n"	// condition code as uint
	 "	srl	%0,28		\n"	// cc = condition code
	 :"=d"(cc)
	 :"d" (digest_p),"d" (msgP),"d" (msgL)
	 :"cc","0","1","6","7");
#endif

	return cc;
} // end KIMD

/*********************************************************************/
/*         r0 = 0x01                                                 */
/*         r1 = digest_p                                             */
/*         r6 = msgP                                                 */
/*         r7 = msgL                                                 */
/*           KLMD (6)                                                */
/*         until cc != 3                                             */
/*********************************************************************/
static int KLMD(unsigned char *digest_p,
		unsigned char *msgP,
		unsigned long msgL)
{
	register int cc = 0;

	asm volatile
#ifdef _LINUX_S390X_
	("	slgr	0,0		\n"	// R0 = 0;
	 "	lghi	0,1		\n"	// R0 = 0x01
	 "	lgr	1,%1		\n"	// R1 = digest_p
	 "	lgr	6,%2		\n"	// R6 = message_p
	 "	lgr	7,%3		\n"	// R7 = messageLen
	 "0:	.long	0xb93f0006	\n"	// KLMD
	 "1:	brc	1,0b		\n"	// keep going while cc=3
	 "	ipm	%0		\n"	// condition code as uint
	 "	srl	%0,28		\n"	// cc = condition code
	 :"=d"(cc)
	 :"d" (digest_p),"d" (msgP),"d" (msgL)
	 :"cc","0","1","6","7");
#else
	("	slr	0,0		\n"	// R0 = 0;
	 "	lhi	0,1		\n"	// R0 = 0x01
	 "	lr	1,%1		\n"	// R1 = digest_p
	 "	lr	6,%2		\n"	// R6 = message_p
	 "	lr	7,%3		\n"	// R7 = messageLen
	 "0:	.long	0xb93f0006	\n"	// KLMD
	 "1:	brc	1,0b		\n"	// keep going while cc=3
	 "	ipm	%0		\n"	// condition code as uint
	 "	srl	%0,28		\n"	// cc = condition code
	 :"=d"(cc)
	 :"d" (digest_p),"d" (msgP),"d" (msgL)
	 :"cc","0","1","6","7");
#endif

	return cc;
} // end KLMD

int queryEnvExtraSigillChecks(void)
{
	// If there is an environment variable, add extra checks.
	if (getenv("LIBICA_SIGILL_CHECKS") != NULL)
		return 1;

	// Otherwise, no extra checks.
	return 0;
}

int extra_sigill_checks = 0;

void queryCryptoAssist(void)
{
	struct sigaction new, old;
	sigset_t newset, oldset;

	if (cpacf_checked)
		return;

	extra_sigill_checks = queryEnvExtraSigillChecks();

	cpacf_checked = 1;
	des_switch = 0;
	sha1_switch = 0;
	sigemptyset(&newset);
	sigaddset(&newset, SIGILL);
	sigprocmask(SIG_UNBLOCK, &newset, &oldset);
	new.sa_handler = (void *) sigill_handler;
	new.sa_flags = 0;
	sigaction(SIGILL, &new, &old);

	if (setjmp(envq) == 0) {
		querySHA1();
		queryDES();
	}
	sigaction(SIGILL, &old, NULL);
	sigprocmask(SIG_SETMASK, &oldset, NULL);
}
#else // Non-zSeries platforms do not have CryptoAssist
void queryCryptoAssist(void)
{
}
#endif

static inline char * alloc_devicename(char *devicename, unsigned int id)
{
  char *fixed;
  size_t size;

  /* How much memory should I allocate for the new
   * device name?  I'll allow MAXBASESIZE for the devicename
   * and MAXMINORSIZE for whatever the minor number asciis out to.
   */

  size = strnlen(devicename, MAXBASESIZE) + MAXMINORSIZE;

  fixed = (char *)malloc(size);

  if(fixed){
    memset(fixed, 0x00, size);

    if(size == snprintf(fixed, size-1, "%s%u", devicename, id)){
      /* Shouldn't happen, but if it does let just stop. */
      free(fixed);
      return(NULL);
    }
  }

  return fixed;
}

static inline void free_devicename(char *devicename)
{
#ifndef _LINUX_S390_
  free(devicename);
#endif
}

/*---------------------------------------------------------------------*
 |                                                                     |
 | NAME:        check_des_parms                                        |
 |                                                                     |
 | FUNCTION:    Check the parameters passed from the application for   |
 |              DES operations.                                        |
 |                                                                     |
 | RETURN:      zero if successfull, nonzero if failure.               |
 |                                                                     |
 | Note:  There are no checks for really stupid errors like the        |
 |        key, chaining vector, outputs and inputs overlapping.        |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
check_des_parms( ICA_ADAPTER_HANDLE      hAdapterHandle,
		 unsigned int            mode,
		 unsigned int            dataLength,
		 unsigned char          *pInputData,
		 ICA_DES_VECTOR         *pIv,
		 ICA_KEY_DES_TRIPLE     *pKeyDes,
		 unsigned int           *pOutputDataLength,
		 unsigned char          *pOutputData )
{
     /* check for obvious errors in parms */

     if( (pInputData == NULL             )           ||
	 ((pIv == NULL)  && (mode == MODE_DES_CBC )) ||
	 (pKeyDes == NULL                )           ||
	 (pOutputDataLength == NULL      )           ||
	 (pOutputData == NULL            )           ||
         ((mode != MODE_DES_ECB) && (mode != MODE_DES_CBC )) ||
	 (dataLength & 0x07              )           ||
	 (dataLength > *pOutputDataLength) ) {

	  return( HDDInvalidParm );
     }

     return( 0 );
}





/*---------------------------------------------------------------------*
 |                                                                     |
 | NAME: icaOpenAdapter                                                |
 |                                                                     |
 | FUNCTION:  Opens the specified adapter                              |
 |                                                                     |
 | PARAMETERS:                                                         |
 |              adapterId - the adapter number                         |
 |              pAdapterHandle - pointer to where the file descriptor  |
 |                                                                     |
 | RETURN:      return code i 0 for success, non-zero for failure      |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaOpenAdapter(unsigned int         adapterId,
               ICA_ADAPTER_HANDLE  *pAdapterHandle)
{
	unsigned int rc, err = 0, use_default = 0;
	char *name;
#ifdef _LINUX_S390_
	struct ica_z90_status ica_stat;
	int totalcount, rv = 0;
#endif


	/* check for obvious problems with the parms */
	if (pAdapterHandle == NULL)
		return HDDInvalidParm;

	name = getenv("LIBICA_CRYPT_DEVICE");

        if (name) { /* Only try the user-specified device */
		name = alloc_devicename(name, adapterId);
		if (!name)
			return -ENOMEM;
		rc = open(name, O_RDWR);
		if ((rc == -1) && (adapterId == 0)) {
			name[strlen(name)-1] = '\0';
			rc = open(name, O_RDWR);
		}
		free_devicename(name);
	} else { /* try the defaults */
#ifndef _LINUX_S390_
		name = DEFAULT_CRYPT_DEVICE;
		name = alloc_devicename(name, adapterId);
		if (!name)
			return -ENOMEM;
		rc = open(name, O_RDWR);
		/*
		 * If open failed, and we were trying to open the first
		 * (index 0) adapter, let's try to fall back to using the
		 * device name without the appended adapter number. For
		 * example, 'ica' instead of 'ica0'
		 */
		if ((rc == -1) && (adapterId == 0)) {
			name[strlen(name)-1] = '\0';
			rc = open(name, O_RDWR);
		}
		free_devicename(name);
		if (rc == -1) {
			name = DEFAULT2_CRYPT_DEVICE;
			name = alloc_devicename(name, adapterId);
			rc = open(name, O_RDWR);
			/* Same check as before */
			if ((rc == -1) && (adapterId == 0)) {
				name[strlen(name)-1] = '\0';
				rc = open(name, O_RDWR);
			}
			free_devicename(name);
		}
		if (rc == -1)
			err = errno;
		else
			*pAdapterHandle = rc;
#else
		name = DEFAULT_CRYPT_DEVICE;
		rc = open(name, O_RDWR);
		if (rc == -1) {
			name = DEFAULT2_CRYPT_DEVICE;
			rc = open(name, O_RDWR);
		}
		if (rc == -1) {
			err = errno;
		} else {
			/*
			 * In S390, ensure that there's at least one physical
			 * device present or that the DES crypto assist
			 * instruction is available. If neither condition is
			 * met, close the logical device and return 'open
			 * failed'.
			 */
			rv = ioctl(rc, Z90STAT_TOTALCOUNT, &totalcount);
			if (rv == -ENOTTY) {
				rv = ioctl(rc, ICAZ90STATUS, &ica_stat);
				totalcount = ica_stat.totalcount;
			}
			if ((rv != 0) || (totalcount == 0)) {
				if (!sha1_switch) {
					return ENOENT;
				}
			}
			*pAdapterHandle = rc;
		}
#endif
	}

	return err;
}


/*---------------------------------------------------------------------*
 |                                                                     |
 | icaCloseAdapter                                                     |
 |                                                                     |
 | Purpose: Closes a device handle.                                    |
 |                                                                     |
 | Parameters:                                                         |
 |    pAdapterHandle - pointer to a previously opened device handle.   |
 |                                                                     |
 | Return code: Zero if successful                                     |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaCloseAdapter( ICA_ADAPTER_HANDLE adapterHandle )
{

     if( close(adapterHandle) ){
       return errno;
     }

     return 0;
}

/*---------------------------------------------------------------------*
 |                                                                     |
 | icaSha1                                                             |
 |                                                                     |
 | Purpose: Perform secure hash on input data using the SHA-1          |
 |          algorithm.                                                 |
 |                                                                     |
 | Parameters:                                                         |
 |    hAdapterHandle - pointer to a previously opened device handle.   |
 |                                                                     |
 |    shaMessagePart - the message chaining state. Must be one of the  |
 |                     following:                                      |
 |                                                                     |
 |                     SHA_MSG_PART_ONLY   - A single hash operation   |
 |                     SHA_MSG_PART_FIRST  - The first part            |
 |                     SHA_MSG_PART_MIDDLE - The middle part           |
 |                     SHA_MSG_PART_FINAL  - The last part             |
 |                                                                     |
 |    inputDataLength - the byte length of the input data to be        |
 |                      SHA-1 hashed and must be greater than zero.    |
 |                                                                     |
 |    pInputData - pointer to the input data data.                     |
 |                                                                     |
 |    shaContextLength - specifies the length of the SHA message       |
 |                       context structure.                            |
 |                                                                     |
 |    pShaContext - pointer to the SHA-1 context structure used to     |
 |                  store the intermediate values when chaining is     |
 |                  used. The application must not modify the contents |
 |                  of this structure when chaining is used.           |
 |                                                                     |
 |    pOutputDataLength - on input specifies the length of the         |
 |                        pOutputData buffer and must be greater than  |
 |                        20. On output it contains the actual byte    |
 |                        length of the hash returned in pOutputData.  |
 |                                                                     |
 |    pOutputData - pointer to the buffer to contain the resulting     |
 |                  hash data.                                         |
 |                                                                     |
 | Return code: Zero if successful                                     |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaSha1( ICA_ADAPTER_HANDLE      hAdapterHandle,
	 unsigned int            shaMessagePart,
	 unsigned int            inputDataLength,
	 unsigned char          *pInputData,
	 unsigned int            shaContextLength,
	 SHA_CONTEXT            *pShaContext,
	 unsigned int           *pOutputDataLength,
	 unsigned char          *pOutputData )
{
     ica_sha1_t        rb;
     int               rc;
     char              pad[ICA_SHA_BLOCKLENGTH * 2];
     __u64              leftover;
     ica_sha1_result_t *initialh;

     /* check for obvious errors in parms */
     if( ( pInputData == NULL                    )   ||
	 ( pShaContext == NULL                   )   ||
	 ( pOutputDataLength == NULL             )   ||
	 ( pOutputData == NULL                   )   ||
	 ( *pOutputDataLength < 20               )   ||
	 ( shaContextLength < LENGTH_SHA_CONTEXT ) ) {

	  return( HDDInvalidParm );
     }


     /* make sure some message part is specified */
     if ( ( shaMessagePart != SHA_MSG_PART_ONLY   )   &&
	  ( shaMessagePart != SHA_MSG_PART_FIRST  )   &&
	  ( shaMessagePart != SHA_MSG_PART_MIDDLE )   &&
	  ( shaMessagePart != SHA_MSG_PART_FINAL  ) ) {

	  return( HDDInvalidParm );
     }

     /* check for maximum and minimum input data length */
#ifndef _LINUX_S390_
     if( inputDataLength > 0x01fffffc )
	  return( HDDInvalidParm );
#endif

     /* if this is the first or middle part, the input */
     /*   data length must be a multiple of 64 bytes   */
     if( ( inputDataLength & 0x3f                    )  &&
	 ( ( shaMessagePart == SHA_MSG_PART_FIRST  )    ||
	   ( shaMessagePart == SHA_MSG_PART_MIDDLE ) ) ) {

	  return( HDDInvalidParm );
     }

     /*
      * If this is the middle or final part, the running
      * length should not be zero
      */
#ifndef _LINUX_S390_
     if( ( pShaContext->runningLength == 0         )     &&
	 ( ( shaMessagePart == SHA_MSG_PART_MIDDLE )     ||
	   ( shaMessagePart == SHA_MSG_PART_FINAL ) ) ) {

	  return( HDDInvalidParm );
     }
#endif

#ifdef _LINUX_S390_
	rb.inputdata = pInputData;
	rb.inputdatalength = inputDataLength;
	rb.outputdata = (ica_sha1_result_t *)pOutputData;
	rb.initialh = &pShaContext->shaHash;

	if (sha1_switch) {
		//
		// In zLinux, the hardware performs padding and
		// appropriate initialization, so we'll skip that part here.
		//
		rc = zSha1(&rb, shaMessagePart, &pShaContext->runningLength);
		if (!rc) {
			memcpy(&pShaContext->shaHash, pOutputData,
				ICA_SHA_DATALENGTH);
		}
		return(rc);
	} else {
		rc = icaSha1SW(&rb,
				shaMessagePart,
				&pShaContext->runningLength,
				pOutputData);
		if (!rc) {
			memcpy(&pShaContext->shaHash, pOutputData,
				ICA_SHA_DATALENGTH);
		}
		return(rc);
	}
#else // not 390
     /* Initialize the sha context if this our first
      * (or only) time
      */

     if( (shaMessagePart == SHA_MSG_PART_ONLY) ||
	 (shaMessagePart == SHA_MSG_PART_FIRST)){

       pShaContext->runningLength = 0;
       memset(&pShaContext->shaHash, 0x00, LENGTH_SHA_HASH);

     }

     if(shaMessagePart == SHA_MSG_PART_ONLY ||
        shaMessagePart == SHA_MSG_PART_FIRST){
       initialh = NULL;
     } else {
       initialh = (ica_sha1_result_t *)&pShaContext->shaHash;
     }

     /*
      * Process non-padded block
      */

     rb.inputdata = pInputData;
     leftover = inputDataLength % ICA_SHA_BLOCKLENGTH;
     rb.inputdatalength = inputDataLength - leftover;
     rb.outputdata = (ica_sha1_result_t *)pOutputData;
     rb.initialh = initialh;


     if(rb.inputdatalength > 0){

	rc = ioctl(hAdapterHandle, ICASHA1, &rb);
	if(rc == -1)
	  return errno;

	initialh = (ica_sha1_result_t *)pOutputData;
      }



     /*
      * Do SHA-1 padding for last block?  The format for such padding
      * looks like:
      *   data
      *   binary 1
      *   fill with binary 0s
      *   last qword - bit length of original data
      */

     if( (shaMessagePart == SHA_MSG_PART_ONLY)  ||
	 (shaMessagePart == SHA_MSG_PART_FINAL) ) {
       __u64        bitlength;
       unsigned int count;

       /*
	* Prefill with 0's, copy in data, set first byte to 0x80
	* Note:  this API only deals with byte oriented data even though
	* SHA-1 is bit oriented.   This is why I get away with slapping
	* a 0x80 to deal with the binary 1 directy following the data.
	*/

       memset(pad, 0x00, ICA_SHA_BLOCKLENGTH * 2);
       memcpy(pad, pInputData + inputDataLength - leftover, leftover);
       memset(pad + leftover, 0x80, 1);

       /*
	* Calculate bitlength and convert to big endian if needed.
       	*/

       /* Here bitlength is computed in 2 separate assignments due
       * to a possible Pentium III bug. Oddly enough, on the
       * Pentium III Coppermine machine this was tested on,
       *   bitlength = pShaContext->runningLength + inputDataLength;
       * was returning an incorrect result. The assembly gcc created
       * should have been correct, based on the Intel programmer's
       * manual.  Weird. - KEY
       */
       bitlength = pShaContext->runningLength;
       bitlength += inputDataLength;

       bitlength *= 8;
       bitlength = htobe64(bitlength);

       /* If our leftover data runs into the bitlength field, we'll need
	* to overflow to another padding block.
	*/

       if(leftover >= (ICA_SHA_BLOCKLENGTH - sizeof(__u64))){
	 count = ICA_SHA_BLOCKLENGTH * 2;
       } else {
	 count = ICA_SHA_BLOCKLENGTH;
       }

       /* Set the bitlength field */

       memcpy(pad + count - sizeof(__u64), &bitlength, sizeof(bitlength));



       rb.inputdata = pad;
       rb.inputdatalength = count;
       rb.outputdata = (ica_sha1_result_t *)pOutputData;
       rb.initialh = initialh;



       rc = ioctl(hAdapterHandle, ICASHA1, &rb);
       if(rc == -1)
	 return errno;

     }

     pShaContext->runningLength += inputDataLength;
     memcpy(&pShaContext->shaHash, pOutputData, ICA_SHA_DATALENGTH);

     return( 0 );
#endif
}

/*---------------------------------------------------------------------*
 |                                                                     |
 | icaRandomNumberGenerate                                             |
 |                                                                     |
 | Purpose: Generate a random number.                                  |
 |                                                                     |
 | Parameters:                                                         |
 |    hAdapterHandle - pointer to a previously opened device handle.   |
 |                                                                     |
 |    pOutputDataLength - specifies the byte length of the pOutputData |
 |                        buffer and the desired length of the random  |
 |                        number.                                      |
 |                                                                     |
 |    pOutputData - pointer to the buffer to contain the resulting     |
 |                  random number.                                     |
 |                                                                     |
 | Return code: Zero if successful                                     |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaRandomNumberGenerate( ICA_ADAPTER_HANDLE  hAdapterHandle,
                         unsigned int        outputDataLength,
                         unsigned char      *pOutputData )
{
  /* check for obvious errors in parms */
  if( pOutputData == NULL){
    return HDDInvalidParm;
  }

#ifdef _LINUX_S390_
  // We'll reuse our local copy of hAdapterHandle
  hAdapterHandle = open("/dev/urandom", O_RDONLY);
  if (hAdapterHandle == -1)
    return errno;
#endif

  if( read( hAdapterHandle, pOutputData, outputDataLength ) == -1 ) {
#ifdef _LINUX_S390_
          close(hAdapterHandle);
#endif
          return( errno );
  }

#ifdef _LINUX_S390_
  close(hAdapterHandle);
#endif

  return 0;
}

/*----------------------------------------------------------------------
  mapSysErr
         - Maps an operating system error to a crypto error.
         - Returns the appropriate crypto error.
-----------------------------------------------------------------------*/
unsigned int  mapSysErr( unsigned long  rc )
{


  return( HOST_OS_ERR | (rc & 0xFFFF) );      // Error reported by the OS


}

/*---------------------------------------------------------------------*
 |                                                                     |
 | icaRsaModExpo                                                       |
 |                                                                     |
 | Purpose: Perform a RSA encryption/decryption operation using a      |
 |          key in modulus/exponent form.                              |
 |                                                                     |
 | Parameters:                                                         |
 |    hAdapterHandle - pointer to a previously opened device handle.   |
 |                                                                     |
 |    inputDataLength - the byte length of the input data and must     |
 |                      be 1 to 256 inclusive.                         |
 |                                                                     |
 |    pInputData - pointer to input data to be encrypted/decrypted and |
 |                      is in big endian format.                       |
 |                                                                     |
 |    pKeyModExpo - pointer to the key to be used, in modulus/exponent |
 |                  format.                                            |
 |                                                                     |
 |    pOutputDataLength - on input it contains the byte length of      |
 |                        pOutputData and must be as large as the      |
 |                        modulus byte length. On output it contains   |
 |                        the actual byte length of pOutputData.       |
 |                                                                     |
 |    pOutputData - pointer to where the output results are to be      |
 |                  placed.                                            |
 |                                                                     |
 | Return code: Zero if successful                                     |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaRsaModExpo( ICA_ADAPTER_HANDLE    hAdapterHandle,
               unsigned int          inputDataLength,
               unsigned char        *pInputData,
               ICA_KEY_RSA_MODEXPO  *pKeyModExpo,
               unsigned int         *pOutputDataLength,
               unsigned char        *pOutputData )
{
     ica_rsa_modexpo_t   rb;
     int                 bytelength;
     unsigned char       pad[256];
     unsigned char      *inputdata;
     int                 rc;         // returned



     /* check for obvious errors in parms */
     if( (  inputDataLength < 1                        )  ||
	 (  inputDataLength > 256                      )  ||
	 (  pInputData == NULL                         )  ||
	 (  pKeyModExpo == NULL                        )  ||
	 (  pOutputData == NULL                        )) {

	  return( HDDInvalidParm );
     }



     bytelength = (pKeyModExpo->modulusBitLength+7)/8;

     if(inputDataLength > bytelength){
       return(HDDInvalidParm);
     }

     if(inputDataLength == bytelength){
       inputdata = pInputData;
     } else {
       memset(pad, 0x00, 256);
       memcpy(pad + bytelength - inputDataLength, pInputData, inputDataLength);
       inputdata = pad;
     }

     /* fill driver structure */
     rb.inputdata           = inputdata;
     rb.inputdatalength     = bytelength;

     rb.outputdata          = pOutputData;
     rb.outputdatalength    = bytelength;

     rb.b_key               = &pKeyModExpo->keyRecord[0];
     rb.n_modulus           = &pKeyModExpo->keyRecord[bytelength];

#ifdef _LINUX_S390_

     rc = ioctl(hAdapterHandle, ICARSAMODEXPO, &rb);

     if (rc == -1) {
       if ((errno == 135) || (errno == ENODEV)) { // 135=EGETBUFF (old z90crypt)
         rc = icaRsaModExpoSW(&rb);
         if (rc == 0) {
           *pOutputDataLength = bytelength;
         }
       }
       else {
         perror("ioctl2");
         return( errno );
       }
     }
     else if (rc == 0) {
       *pOutputDataLength = bytelength;
     }
     else {     // rc > 0
       rc = icaRsaModExpoSW(&rb);
       if (rc == 0) {
         *pOutputDataLength = bytelength;
       }
     }

     return (rc);

#else
     if( ioctl( hAdapterHandle, ICARSAMODEXPO, &rb ) == -1 )  {
       perror("ioctl2");
          /* op failed; return errno */
          return( errno );
     }

     *pOutputDataLength = bytelength;



     return( 0 );
#endif // end if S390

} // end icsRsaModExpo

/*---------------------------------------------------------------------*
 |                                                                     |
 | icaRsaCrt                                                           |
 |                                                                     |
 | Purpose: Perform a RSA decryption on input data using a key in      |
 |          Chinese Remainder Thereom (CRT) format.                    |
 |                                                                     |
 | Parameters:                                                         |
 |    hAdapterHandle - pointer to a previously opened device handle.   |
 |                                                                     |
 |    inputDataLength - the byte length of the input data and must     |
 |                      be 1 to 256 inclusive.                         |
 |                                                                     |
 |    pInputData - pointer to input data to be decrypted and           |
 |                      is in big endian format.                       |
 |                                                                     |
 |    pKeyModCrt - pointer to the key to be used, in CRT format.       |
 |                                                                     |
 |    pOutputDataLength - on input it contains the byte length of      |
 |                        pOutputData and must be as large as the      |
 |                        modulus byte length. On output it contains   |
 |                        the actual byte length of pOutputData.       |
 |                                                                     |
 |    pOutputData - pointer to where the output results are to be      |
 |                  placed.                                            |
 |                                                                     |
 | Return code: Zero if successful                                     |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaRsaCrt( ICA_ADAPTER_HANDLE     hAdapterHandle,
	   unsigned int           inputDataLength,
	   unsigned char         *pInputData,
	   ICA_KEY_RSA_CRT       *pKeyCrt,
	   unsigned int          *pOutputDataLength,
	   unsigned char         *pOutputData )
{
  ica_rsa_modexpo_crt_t   rb;
  int                 bytelength;
  unsigned char       pad[256];
  unsigned char      *inputdata;
  int                 rc;                  // returned

     /* check for obvious errors in parms */
     if( (  inputDataLength < 1                    )  ||
	 (  inputDataLength > 256                  )  ||
	 (  pInputData == NULL                     )  ||
	 (  pKeyCrt == NULL                        )  ||
	 (  pOutputDataLength == NULL              )  ||
	 ( *pOutputDataLength <
	   ( (pKeyCrt->modulusBitLength + 7) / 8 ) )  ||
	 (  pOutputData == NULL                    )  ){

	  return( HDDInvalidParm );
     }


     bytelength = (pKeyCrt->modulusBitLength+7)/8;

     if(inputDataLength > bytelength)
       return(HDDInvalidParm);


     if(inputDataLength == bytelength){
       inputdata = pInputData;
     } else {
       memset(pad, 0x00, 256);
       memcpy(pad + bytelength - inputDataLength, pInputData, inputDataLength);
       inputdata = pad;
     }

     /* fill driver structure */
     rb.inputdata           = inputdata;
     rb.inputdatalength     = bytelength;

     rb.outputdata          = pOutputData;
     rb.outputdatalength    = bytelength;

     bytelength /=2;

     rb.bp_key           = &pKeyCrt->keyRecord[0];
     rb.bq_key           = &pKeyCrt->keyRecord[bytelength+8];
     rb.np_prime         = &pKeyCrt->keyRecord[bytelength*2+8];
     rb.nq_prime         = &pKeyCrt->keyRecord[bytelength*3+16];
     rb.u_mult_inv       = &pKeyCrt->keyRecord[bytelength*4+16];


#ifdef _LINUX_S390_
     rc = ioctl(hAdapterHandle, ICARSACRT, &rb);

     if (rc == -1) {
       if ((errno == 135) || (errno == ENODEV)) { // 135=EGETBUFF (old z90crypt)
         rc = icaRsaCrtSW(&rb);
         if (rc == 0) {
           *pOutputDataLength = (bytelength * 2);
         }
	 else {
         }
       }
       else {
         rc = errno;
       }
     }
     else if (rc == 0) {
       *pOutputDataLength = (bytelength * 2);
     }
     else {// rc > 0
       rc = icaRsaCrtSW(&rb);
       if (rc == 0) {
         *pOutputDataLength = (bytelength * 2);
       }
     }

     return (rc);

#else

     if( ioctl( hAdapterHandle, ICARSACRT, &rb ) == -1 ){
          /* op failed; return errno */
          return( errno );
     }

    *pOutputDataLength = (bytelength * 2);

     return( 0 );

#endif

}


/*---------------------------------------------------------------------*
 |                                                                     |
 | icaDesEncrypt                                                       |
 |                                                                     |
 | Purpose: Encrypt data using a single length DES key.                |
 |                                                                     |
 | Parameters:                                                         |
 |    hAdapterHandle - pointer to a previously opened device handle.   |
 |                                                                     |
 |    mode - specifies the operational mode and must be:               |
 |                                                                     |
 |           MODE_DES_ECB - use Electronic Code Book mode              |
 |           MODE_DES_CBC - use Cipher Block Chaining mode             |
 |                                                                     |
 |    dataLength - specifies the byte length of the input data.        |
 |                 Must be a mutiple of the cipher block.              |
 |                                                                     |
 |    pInputData - pointer to the input data data to be encrypted.     |
 |                                                                     |
 |    pIv - pointer to a valid 8 byte initialization vector.           |
 |                                                                     |
 |    pKeyDes - pointer to a single length DES key.                    |
 |                                                                     |
 |    pOutputDataLength - on input specifies the length of the         |
 |                        pOutputData buffer and must be as large as   |
 |                        dataLength. On output it contains the        |
 |                        actual byte length of the data returned in   |
 |                        pOutputData.                                 |
 |                                                                     |
 |    pOutputData - pointer to the buffer to contain the resulting     |
 |                  encrypted data.                                    |
 |                                                                     |
 | Return code: Zero if successful                                     |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaDesEncrypt( ICA_ADAPTER_HANDLE      hAdapterHandle,
	       unsigned int            mode,
	       unsigned int            dataLength,
	       unsigned char          *pInputData,
	       ICA_DES_VECTOR         *pIv,
	       ICA_KEY_DES_SINGLE     *pKeyDes,
	       unsigned int           *pOutputDataLength,
	       unsigned char          *pOutputData )
{
     ica_des_t         des;
     int rv = 0;

     /* check for obvious errors in parms */
     if( check_des_parms( hAdapterHandle,
			  mode,
			  dataLength,
			  pInputData,
			  pIv,
			  (ICA_KEY_DES_TRIPLE *)pKeyDes,
			  pOutputDataLength,
			  pOutputData ) ) {
	  return( HDDInvalidParm );
     }

     des.mode = mode==MODE_DES_ECB?DEVICA_MODE_DES_ECB:DEVICA_MODE_DES_CBC;
     des.direction = DEVICA_DIR_DES_ENCRYPT;
     des.inputdata = pInputData;
     des.inputdatalength = dataLength;
     des.iv = (ica_des_key_t *)pIv;
     des.keys = (ica_des_key_t *)pKeyDes;

     des.outputdata = pOutputData;
     des.outputdatalength = *pOutputDataLength;

#ifdef _LINUX_S390_
	if (des_switch) {
		*pOutputDataLength = dataLength;
		rv = zDes(&des,sizeof(ICA_KEY_DES_SINGLE));
		if (rv == EXCEPTION_RV) {
			rv = icaDesSW(mode,
				      dataLength,
				      DES_ENCRYPT,
				      pInputData,
				      pIv,
				      pKeyDes,
				      pOutputDataLength,
				      pOutputData);
		}
	} else {
		rv = icaDesSW(mode,
			      dataLength,
			      DES_ENCRYPT,
			      pInputData,
			      pIv,
			      pKeyDes,
			      pOutputDataLength,
			      pOutputData);
	}
	return rv;
#else // not S390
     if( ioctl( hAdapterHandle, ICADES, &des ) == -1 ) {

       /* op failed; return errno */
       return( errno );
     }

     *pOutputDataLength = dataLength;

     return( 0 );
#endif // _LINUX_S390_
}

/*---------------------------------------------------------------------*
 |                                                                     |
 | icaDesDecrypt                                                       |
 |                                                                     |
 | Purpose: Decrypt data using a single length DES key.                |
 |                                                                     |
 | Parameters:                                                         |
 |    hAdapterHandle - pointer to a previously opened device handle.   |
 |                                                                     |
 |    mode - specifies the operational mode and must be:               |
 |                                                                     |
 |           MODE_DES_ECB - use Electronic Code Book mode              |
 |           MODE_DES_CBC - use Cipher Block Chaining mode             |
 |                                                                     |
 |    dataLength - specifies the byte length of the input data.        |
 |                 Must be a mutiple of the cipher block.              |
 |                                                                     |
 |    pInputData - pointer to the input data data to be decrypted.     |
 |                                                                     |
 |    pIv - pointer to a valid 8 byte initialization vector.           |
 |                                                                     |
 |    pKeyDes - pointer to a single length DES key.                    |
 |                                                                     |
 |    pOutputDataLength - on input specifies the length of the         |
 |                        pOutputData buffer and must be as large as   |
 |                        dataLength. On output it contains the        |
 |                        actual byte length of the data returned in   |
 |                        pOutputData.                                 |
 |                                                                     |
 |    pOutputData - pointer to the buffer to contain the resulting     |
 |                  decrypted data.                                    |
 |                                                                     |
 | Return code: Zero if successful                                     |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaDesDecrypt( ICA_ADAPTER_HANDLE      hAdapterHandle,
	       unsigned int            mode,
	       unsigned int            dataLength,
	       unsigned char          *pInputData,
	       ICA_DES_VECTOR         *pIv,
	       ICA_KEY_DES_SINGLE     *pKeyDes,
	       unsigned int           *pOutputDataLength,
	       unsigned char          *pOutputData )
{
     ica_des_t         des;
#ifdef _LINUX_S390_
	int rv = 0;
#endif // LINUX_S390

     /* check for obvious errors in parms */
     if( check_des_parms( hAdapterHandle,
			  mode,
			  dataLength,
			  pInputData,
			  pIv,
			  (ICA_KEY_DES_TRIPLE *)pKeyDes,
			  pOutputDataLength,
			  pOutputData ) ) {
	  return( HDDInvalidParm );
     }

     des.mode = mode==MODE_DES_ECB?DEVICA_MODE_DES_ECB:DEVICA_MODE_DES_CBC;
     des.direction = DEVICA_DIR_DES_DECRYPT;
     des.inputdata = pInputData;
     des.inputdatalength = dataLength;
     des.iv = (ica_des_key_t *)pIv;
     des.keys = (ica_des_key_t *)pKeyDes;
     des.outputdata = pOutputData;
     des.outputdatalength = *pOutputDataLength;

#ifdef _LINUX_S390_
	if (des_switch) {
		*pOutputDataLength = dataLength;
		rv = zDes(&des,sizeof(ICA_KEY_DES_SINGLE));
		if (rv == EXCEPTION_RV) {
			rv = icaDesSW(mode,
				      dataLength,
				      DES_DECRYPT,
				      pInputData,
				      pIv,
				      pKeyDes,
				      pOutputDataLength,
				      pOutputData);
		}
	} else {
		rv = icaDesSW(mode,
			      dataLength,
			      DES_DECRYPT,
			      pInputData,
			      pIv,
			      pKeyDes,
			      pOutputDataLength,
			      pOutputData);
	}
	return rv;
#else // not S390
     if( ioctl( hAdapterHandle, ICADES, &des ) == -1 ) {
          /* op failed; return errno */
          return( errno );
     }

     *pOutputDataLength = dataLength;

     return( 0 );
#endif // _LINUX_S390_
}

/*---------------------------------------------------------------------*
 |                                                                     |
 | icaTDesEncrypt                                                      |
 |                                                                     |
 | Purpose: Encrypt data using a triple length DES key.                |
 |                                                                     |
 | Parameters:                                                         |
 |    hAdapterHandle - pointer to a previously opened device handle.   |
 |                                                                     |
 |    mode - specifies the operational mode and must be:               |
 |                                                                     |
 |           MODE_DES_ECB - use Electronic Code Book mode              |
 |           MODE_DES_CBC - use Cipher Block Chaining mode             |
 |                                                                     |
 |    dataLength - specifies the byte length of the input data.        |
 |                 Must be a mutiple of the cipher block.              |
 |                                                                     |
 |    pInputData - pointer to the input data data to be encrypted.     |
 |                                                                     |
 |    pIv - pointer to a valid 8 byte initialization vector.           |
 |                                                                     |
 |    pKeyDes - pointer to a triple length DES key.                    |
 |                                                                     |
 |    pOutputDataLength - on input specifies the length of the         |
 |                        pOutputData buffer and must be as large as   |
 |                        dataLength. On output it contains the        |
 |                        actual byte length of the data returned in   |
 |                        pOutputData.                                 |
 |                                                                     |
 |    pOutputData - pointer to the buffer to contain the resulting     |
 |                  encrypted data.                                    |
 |                                                                     |
 | Return code: Zero if successful                                     |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaTDesEncrypt( ICA_ADAPTER_HANDLE      hAdapterHandle,
		unsigned int            mode,
		unsigned int            dataLength,
		unsigned char          *pInputData,
		ICA_DES_VECTOR         *pIv,
		ICA_KEY_DES_TRIPLE     *pKeyDes,
		unsigned int           *pOutputDataLength,
		unsigned char          *pOutputData )
{
     ica_des_t         des;
#ifdef _LINUX_S390_
	int rv = 0;
#endif

     /* check for obvious errors in parms */
     if( check_des_parms( hAdapterHandle,
			  mode,
			  dataLength,
			  pInputData,
			  pIv,
			  pKeyDes,
			  pOutputDataLength,
			  pOutputData ) ) {
	  return( HDDInvalidParm );
     }

     des.mode = mode==MODE_DES_ECB?DEVICA_MODE_DES_ECB:DEVICA_MODE_DES_CBC;
     des.direction = DEVICA_DIR_DES_ENCRYPT;
     des.inputdata = pInputData;
     des.inputdatalength = dataLength;
     des.iv = (ica_des_key_t *)pIv;
     des.keys = (ica_des_key_t *)pKeyDes;

     des.outputdata = pOutputData;
     des.outputdatalength = *pOutputDataLength;

#ifdef _LINUX_S390_
	if (des_switch) {
		*pOutputDataLength = dataLength;
		rv = zDes(&des,sizeof(ICA_KEY_DES_TRIPLE));
		if (rv == EXCEPTION_RV) {
			rv = icaTDesSW(mode,
				       dataLength,
				       DES_ENCRYPT,
				       pInputData,
				       pIv,
				       pKeyDes,
				       pOutputDataLength,
				       pOutputData);
		}
	} else {
		rv = icaTDesSW(mode,
			       dataLength,
			       DES_ENCRYPT,
			       pInputData,
			       pIv,
			       pKeyDes,
			       pOutputDataLength,
			       pOutputData);
	}
	return rv;
#else // not S390

     if( ioctl( hAdapterHandle, ICATDES, &des ) == -1 ) {
          /* op failed; return errno */
          return( errno );
     }

     *pOutputDataLength = dataLength;

     return( 0 );
#endif // _LINUX_S390_
}

/*---------------------------------------------------------------------*
 |                                                                     |
 | icaTDesDecrypt                                                      |
 |                                                                     |
 | Purpose: Decrypt data using a triple length DES key.                |
 |                                                                     |
 | Parameters:                                                         |
 |    hAdapterHandle - pointer to a previously opened device handle.   |
 |                                                                     |
 |    mode - specifies the operational mode and must be:               |
 |                                                                     |
 |           MODE_DES_ECB - use Electronic Code Book mode              |
 |           MODE_DES_CBC - use Cipher Block Chaining mode             |
 |                                                                     |
 |    dataLength - specifies the byte length of the input data.        |
 |                 Must be a mutiple of the cipher block.              |
 |                                                                     |
 |    pInputData - pointer to the input data data to be decrypted.     |
 |                                                                     |
 |    pIv - pointer to a valid 8 byte initialization vector.           |
 |                                                                     |
 |    pKeyDes - pointer to a triple length DES key.                    |
 |                                                                     |
 |    pOutputDataLength - on input specifies the length of the         |
 |                        pOutputData buffer and must be as large as   |
 |                        dataLength. On output it contains the        |
 |                        actual byte length of the data returned in   |
 |                        pOutputData.                                 |
 |                                                                     |
 |    pOutputData - pointer to the buffer to contain the resulting     |
 |                  decrypted data.                                    |
 |                                                                     |
 | Return code: Zero if successful                                     |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaTDesDecrypt( ICA_ADAPTER_HANDLE      hAdapterHandle,
		unsigned int            mode,
		unsigned int            dataLength,
		unsigned char          *pInputData,
		ICA_DES_VECTOR         *pIv,
		ICA_KEY_DES_TRIPLE     *pKeyDes,
		unsigned int           *pOutputDataLength,
		unsigned char          *pOutputData )
{
     ica_des_t         des;
#ifdef _LINUX_S390_
	int rv = 0;
#endif

     /* check for obvious errors in parms */
     if( check_des_parms( hAdapterHandle,
			  mode,
			  dataLength,
			  pInputData,
			  pIv,
			  pKeyDes,
			  pOutputDataLength,
			  pOutputData ) ) {
	  return( HDDInvalidParm );
     }

     des.mode = mode==MODE_DES_ECB?DEVICA_MODE_DES_ECB:DEVICA_MODE_DES_CBC;
     des.direction = DEVICA_DIR_DES_DECRYPT;
     des.inputdata = pInputData;
     des.inputdatalength = dataLength;
     des.iv = (ica_des_key_t *)pIv;
     des.keys = (ica_des_key_t *)pKeyDes;

     des.outputdata = pOutputData;
     des.outputdatalength = *pOutputDataLength;

#ifdef _LINUX_S390_
	if (des_switch) {
		*pOutputDataLength = dataLength;
		rv = zDes(&des,sizeof(ICA_KEY_DES_TRIPLE));
		if (rv == EXCEPTION_RV) {
			rv = icaTDesSW(mode,
				       dataLength,
				       DES_DECRYPT,
				       pInputData,
				       pIv,
				       pKeyDes,
				       pOutputDataLength,
				       pOutputData);
		}
	} else {
		rv = icaTDesSW(mode,
			       dataLength,
			       DES_DECRYPT,
			       pInputData,
			       pIv,
			       pKeyDes,
			       pOutputDataLength,
			       pOutputData);
	}
	return rv;
#else // not S390

     if( ioctl( hAdapterHandle, ICATDES, &des ) == -1 ) {
          /* op failed; return errno */
          return( errno );
     }

     *pOutputDataLength = dataLength;

     return( 0 );
#endif // _LINUX_S390_
}

/*---------------------------------------------------------------------*
 |                                                                     |
 | icaRsaModMult                                                       |
 |                                                                     |
 | Purpose: Perform a modular muliplication operation.                 |
 |                                                                     |
 | Parameters:                                                         |
 |    hAdapterHandle - pointer to a previously opened device handle.   |
 |                                                                     |
 |    inputDataLength - the byte length of the input data and must     |
 |                      be 1 to 256 inclusive.                         |
 |                                                                     |
 |    pInputData - pointer to input data to be encrypted/decrypted and |
 |                      is in big endian format.                       |
 |                                                                     |
 |    pKeyModExpo - pointer to the key to be used, in modulus/exponent |
 |                  format.                                            |
 |                                                                     |
 |    pOutputDataLength - on input it contains the byte length of      |
 |                        pOutputData and must be as large as the      |
 |                        modulus byte length. On output it contains   |
 |                        the actual byte length of pOutputData.       |
 |                                                                     |
 |    pOutputData - pointer to where the output results are to be      |
 |                  placed.                                            |
 |                                                                     |
 | Return code: Zero if successful                                     |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaRsaModMult( ICA_ADAPTER_HANDLE    hAdapterHandle,
               unsigned int          inputDataLength,
               unsigned char        *pInputData,
               ICA_KEY_RSA_MODEXPO  *pKeyModExpo,
               unsigned int         *pOutputDataLength,
               unsigned char        *pOutputData )
{
     ica_rsa_modmult_t   rb;
     int                 bytelength;
     unsigned char       pad[256];
     unsigned char      *inputdata;


     /* check for obvious errors in parms */
     if( (  inputDataLength < 1                        )  ||
	 (  inputDataLength > 256                      )  ||
	 (  pInputData == NULL                         )  ||
	 (  pKeyModExpo == NULL                        )  ||
	 (  pOutputData == NULL                        )) {

	  return( HDDInvalidParm );
     }

     bytelength = (pKeyModExpo->modulusBitLength+7)/8;

     if(inputDataLength > bytelength)
       return(HDDInvalidParm);


     if(inputDataLength == bytelength){
       inputdata = pInputData;
     } else {
       memset(pad, 0x00, 256);
       memcpy(pad + bytelength - inputDataLength, pInputData, inputDataLength);
       inputdata = pad;
     }


     /* fill driver structure */
     rb.inputdata           = inputdata;
     rb.inputdatalength     = bytelength;

     rb.outputdata          = pOutputData;
     rb.outputdatalength    = bytelength;

     rb.b_key               = &pKeyModExpo->keyRecord[0];
     rb.n_modulus           = &pKeyModExpo->keyRecord[bytelength];


#ifdef _LINUX_S390_
     return(icaRsaModMultSW(&rb));
#else
     if( ioctl( hAdapterHandle, ICARSAMODMULT, &rb ) == -1 )  {
       perror("ioctl1");
          /* op failed; return errno */
          return( errno );
     }

     *pOutputDataLength = bytelength;

     return( 0 );
#endif
}

#ifdef _LINUX_S390_
/*---------------------------------------------------------------------*
 |                                                                     |
 | icaRsaModExpoSW                                                     |
 |                                                                     |
 | Purpose: Perform a RSA encryption/decryption operation using a      |
 |          key in modulus/exponent form, in software                  |
 |                                                                     |
 | Parameters:                                                         |
 |                                                                     |
 |  address of an ica_rsa_modexpo_t, containing:                       |
 |                                                                     |
 |    inputdatalength - the byte length of the input data              |
 |                                                                     |
 |    inputdata - pointer to input data                                |
 |                                                                     |
 |    b_key - pointer to the exponent                                  |
 |                                                                     |
 |    n_modulus - pointer to the modulus                               |
 |                                                                     |
 |    outputdatalength - on input it contains the byte length of       |
 |                       the output buffer.  On output it contains     |
 |                       the actual byte length of the outputdata      |
 |                                                                     |
 |    outputdata - pointer to the output buffer                        |
 |                                                                     |
 | Return codes: Propagated from ModExpo                               |
 |                                                                     |
 | Process:                                                            |
 |         Pass the lengths and addresses of inputdata, b_key,         |
 |         n_modulus and outputdata to ModExpoSW                       |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaRsaModExpoSW(ica_rsa_modexpo_t *pMex)
{
  int rc = 0;
  BN_CTX * ctx = NULL;

  if ((ctx = BN_CTX_new()) == NULL) {
    return HDDBufferTooSmall;
  }

  rc = ModExpoSW(pMex->inputdatalength, pMex->inputdata,
                 pMex->inputdatalength, pMex->b_key,
                 pMex->inputdatalength, pMex->n_modulus,
                 &(pMex->outputdatalength), pMex->outputdata, ctx);

  BN_CTX_free(ctx);

  return (rc);
} // end icaRsaModExpoSW

/*---------------------------------------------------------------------*
 |                                                                     |
 | icaRsaCrtSW                                                         |
 |                                                                     |
 | Purpose: Perform a RSA decryption on input data using a key in      |
 |          Chinese Remainder Theorem (CRT) format, in software        |
 |                                                                     |
 | Parameters:                                                         |
 |                                                                     |
 |  address of an ica_rsa_modexpo_crt_t, containing:                   |
 |                                                                     |
 |    inputdatalength - the byte length of the input data              |
 |                                                                     |
 |    inputdata - pointer to input data  b                             |
 |                                                                     |
 |    outputdatalength - on input it contains the byte length of       |
 |                       the output buffer.  On output it contains     |
 |                       the actual byte length of the outputdata      |
 |                                                                     |
 |    outputdata - pointer to the output buffer                        |
 |                                                                     |
 |    bp_key - pointer to dp                                           |
 |                                                                     |
 |    bq_key - pointer to dq                                           |
 |                                                                     |
 |    np_prime - pointer to p                                          |
 |                                                                     |
 |    nq_prime - pointer to q                                          |
 |                                                                     |
 |    u_mult_inv - pointer to u                                        |
 |                                                                     |
 | Return code: Zero if successful                                     |
 |                                                                     |
 | Process:                                                            |
 |      1) Compute ir1 = b mod p using ModSW                           |
 |      2) Compute temp = ir1 ** dp (mod p) using ModExpoSW            |
 |      3) Copy temp to ir1                                            |
 |      4) Compute ir2 = b mod q using ModSW                           |
 |      5) Compute temp = ir2 ** dq (mod q) using ModExpoSW            |
 |      6) Copy temp to ir2                                            |
 |      7) Compute ir1 = ir1 - ir2 (mod p) using ModSubSW              |
 |      8) Compute temp = ir1 * u modulo p using ModMulSW              |
 |      9) Compute ir1 = temp * q using MulSW                          |
 |     10) Compute result = ir1 + ir2 using AddSW                      |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaRsaCrtSW(ica_rsa_modexpo_crt_t *pCrt)
{
  int rc = 0;
  int longlen = 0;
  int shrtlen = 0;
  int orig_outl;
  char ir1[136];
  int ir1length = sizeof(ir1);
  char ir2[136];
  int ir2length = sizeof(ir2);
  char temp[136];
  int templength = sizeof(temp);

  BN_CTX * ctx = NULL;

  shrtlen = pCrt->inputdatalength/2;
  longlen = shrtlen + 8;

  if ((ctx = BN_CTX_new()) == NULL) {
    return HDDBufferTooSmall;
  }

  memset(ir1,0,sizeof(ir1));
  if ((rc = ModSW(pCrt->inputdatalength, pCrt->inputdata,
                  longlen, pCrt->np_prime,
                  &ir1length, ir1, ctx)) != 0)
    goto err;

  memset(temp,0,sizeof(temp));
  if ((rc = ModExpoSW(ir1length, ir1,
                      longlen, pCrt->bp_key,
                      longlen, pCrt->np_prime,
                      &templength, temp, ctx)) != 0)
    goto err;

  memset(ir1,0,sizeof(ir1));
  memcpy(ir1, temp, templength);
  ir1length = templength;

  memset(ir2, 0, sizeof(ir2));
  if ((rc = ModSW(pCrt->inputdatalength, pCrt->inputdata,
                  shrtlen, pCrt->nq_prime,
                  &ir2length, ir2, ctx)) != 0)
    goto err;

  templength = sizeof(temp);
  memset(temp, 0, sizeof(temp));
  if ((rc = ModExpoSW(ir2length, ir2,
                      shrtlen, pCrt->bq_key,
                      shrtlen, pCrt->nq_prime,
                      &templength, temp, ctx)) != 0)
    goto err;

  memset(ir2,0,sizeof(ir2));
  memcpy(ir2, temp, templength);
  ir2length = templength;

  templength = sizeof(ir1);
  if ((rc = ModSubSW(ir1length, ir1,
                     ir2length, ir2,
                     longlen, pCrt->np_prime,
                     &templength, ir1, ctx)) != 0) {
    if (rc != -1) {
      goto err;
    }
    else {
      if (ir2length > pCrt->outputdatalength) {
        memcpy(pCrt->outputdata,
               ir2 + (ir2length - pCrt->outputdatalength),
               pCrt->outputdatalength);
      }
      else {
        if (ir2length < pCrt->outputdatalength) {
          memset(pCrt->outputdata, 0, (pCrt->outputdatalength - ir2length));
          memcpy(pCrt->outputdata + (pCrt->outputdatalength - ir2length),
                 ir2,
                 ir2length);
        }
        else {
          memcpy(pCrt->outputdata, ir2, ir2length);
        }
      }
      rc = 0;
      goto cleanup;
    }
  }

  ir1length = templength;

  templength = sizeof(temp);
  memset(temp, 0, sizeof(temp));
  if ((rc = ModMulSW(ir1length, ir1,
                     longlen, pCrt->u_mult_inv,
                     longlen, pCrt->np_prime,
                     &templength, temp, ctx)) != 0)
    goto err;

  orig_outl = pCrt->outputdatalength;

  if ((rc = MulSW(templength, temp,
                  shrtlen, pCrt->nq_prime,
                  &(pCrt->outputdatalength), pCrt->outputdata, ctx)) != 0)
    goto err;

  if ((rc = AddSW(pCrt->outputdatalength, pCrt->outputdata,
                  ir2length, ir2,
                  &(pCrt->outputdatalength), pCrt->outputdata, ctx)) != 0)
    goto err;

  goto cleanup;

err:
  rc = HDDInvalidParm;

cleanup:
  BN_CTX_free(ctx);

  return (rc);
} // end icaRsaCrtSW

/*---------------------------------------------------------------------*
 |                                                                     |
 | icaRsaModMultSW                                                     |
 |                                                                     |
 | Purpose: Perform a modular muliplication operation in software      |
 |                                                                     |
 | Parameters:                                                         |
 |                                                                     |
 |  address of an ica_rsa_modmult_t, containing:                       |
 |                                                                     |
 |    inputdatalength - the byte length of the input data              |
 |                                                                     |
 |    inputdata - pointer to first factor                              |
 |                                                                     |
 |    b_key - pointer to the second factor                             |
 |                                                                     |
 |    n_modulus - pointer to the modulus                               |
 |                                                                     |
 |    outputdatalength - on input it contains the byte length of       |
 |                       the output buffer.  On output it contains     |
 |                       the actual byte length of the outputdata      |
 |                                                                     |
 |    outputdata - pointer to the output buffer                        |
 |                                                                     |
 |                                                                     |
 | Return code: Zero if successful                                     |
 |                                                                     |
 | Process:                                                            |
 |         Call ModMulSW with  the argument, exponent, modulus and     |
 |         output data                                                 |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaRsaModMultSW(ica_rsa_modmult_t *pMul)
{
  int rc = 0;
  BN_CTX * ctx = NULL;

  if ((ctx = BN_CTX_new()) == NULL) {
    return HDDBufferTooSmall;
  }

  rc = ModMulSW(pMul->inputdatalength, pMul->inputdata,
                pMul->inputdatalength, pMul->b_key,
                pMul->inputdatalength, pMul->n_modulus,
                &(pMul->outputdatalength), pMul->outputdata, ctx);

  BN_CTX_free(ctx);
  return (rc);
} // end icaRsaModMultSW

/*---------------------------------------------------------------------*
 |                                                                     |
 | icaDesSW                                                            |
 |                                                                     |
 | Purpose: Encrypt/decrypt using a single length DES key in software  |
 |                                                                     |
 | Parameters:                                                         |
 |    mode - specifies the operational mode and must be:               |
 |                                                                     |
 |           MODE_DES_ECB - use Electronic Code Book mode              |
 |           MODE_DES_CBC - use Cipher Block Chaining mode             |
 |                                                                     |
 |    dataLength - specifies the byte length of the input data.        |
 |                 Must be a mutiple of the cipher block.              |
 |                                                                     |
 |    enc - specifies whether this is an encryption or decryption      |
 |                                                                     |
 |          DES_ENCRYPT - encryption                                   |
 |          DES_DECRYPT - decryption                                   |
 |                                                                     |
 |    pInputData - pointer to the input data data to be encrypted.     |
 |                                                                     |
 |    pIv - pointer to a valid 8 byte initialization vector.           |
 |                                                                     |
 |    pKeyDes - pointer to a single length DES key.                    |
 |                                                                     |
 |    pOutputDataLength - on input specifies the length of the         |
 |                        pOutputData buffer and must be as large as   |
 |                        dataLength. On output it contains the        |
 |                        actual byte length of the data returned in   |
 |                        pOutputData.                                 |
 |                                                                     |
 |    pOutputData - pointer to the buffer to contain the resulting     |
 |                  encrypted data.                                    |
 |                                                                     |
 |                                                                     |
 | Process:                                                            |
 |                                                                     |
 |    1.  Ensure inputdatalength is a multiple of 8; if not            |
 |        return an error.                                             |
 |                                                                     |
 |    2.  Copy input key and iv to temp_key and temp_iv                |
 |                                                                     |
 |    3.  Invoke des_set_key_unchecked(temp_key, schedule)             |
 |                                                                     |
 |    4.  If mode is MODE_DES_CBC                                      |
 |          Invoke des_ncbc_encrypt(pInputData,                        |
 |                                  pOutputData,                       |
 |                                  (long) dataLength,                 |
 |                                  schedule,                          |
 |                                  &temp_iv                           |
 |                                  enc)                               |
 |        Otherwise:                                                   |
 |          8 bytes at a time:                                         |
 |            Copy InputData into Temp_input, advancing input pointer  |
 |            Set output pointer to beginning of output buffer         |
 |            Invoke des_ecb_encrypt(pTemp_input,                      |
 |                                   pTemp_ouput,                      |
 |                                   schedule                          |
 |                                   enc)                              |
 |            Copy Temp_output to output buffer,                       |
 |            advancing output pointer                                 |
 |                                                                     |
 |    5.  Set output data length                                       |
 |                                                                     |
 | Return code: Zero if successful                                     |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaDesSW(unsigned int       mode,
	 unsigned int       dataLength,
	 unsigned int       enc,
	 unsigned char      *pInputData,
	 ICA_DES_VECTOR     *pIv,
	 ICA_KEY_DES_SINGLE *pKeyDes,
	 unsigned int       *pOutputDataLength,
	 unsigned char      *pOutputData)
{
  int rc = 0;
  int i;
  des_key_schedule ks;
  const_des_cblock temp_key;
  des_cblock temp_iv;
  const_des_cblock temp_input;
  des_cblock temp_output;

  if (dataLength % 8) {
    *pOutputDataLength = 0;
    return HDDInvalidParm;
  }

  memcpy (&temp_key, pKeyDes, 8);
  des_set_key_unchecked(&temp_key, ks );

  if ( mode == MODE_DES_CBC ) {
    memcpy(&temp_iv, pIv, 8);
    des_ncbc_encrypt((const unsigned char *)pInputData,
		     pOutputData,
		     (long)dataLength,
		     ks,
		     &temp_iv,
		     enc);
  }
  else {
    for (i = 0; i < dataLength; i += 8) {
      memcpy(&temp_input, pInputData + i, 8);
      des_ecb_encrypt(&temp_input,
             	      &temp_output,
	       	      ks,
		      enc);
      memcpy(pOutputData + i, temp_output, 8);
    }
  }

  *pOutputDataLength = dataLength;

  return (rc);
} // end icaDesSW

/*---------------------------------------------------------------------*
 |                                                                     |
 | icaTDesSW                                                           |
 |                                                                     |
 | Purpose: Encrypt/decrypt using a triple length DES key in software  |
 |                                                                     |
 | Parameters:                                                         |
 |    mode - specifies the operational mode and must be:               |
 |                                                                     |
 |           MODE_DES_ECB - use Electronic Code Book mode              |
 |           MODE_DES_CBC - use Cipher Block Chaining mode             |
 |                                                                     |
 |    dataLength - specifies the byte length of the input data.        |
 |                 Must be a mutiple of the cipher block.              |
 |                                                                     |
 |    enc - specifies whether this is an encryption or decryption      |
 |                                                                     |
 |          DES_ENCRYPT - encryption                                   |
 |          DES_DECRYPT - decryption                                   |
 |                                                                     |
 |    pInputData - pointer to the input data data to be encrypted.     |
 |                                                                     |
 |    pIv - pointer to a valid 8 byte initialization vector.           |
 |                                                                     |
 |    pKeyDes - pointer to a triple length DES key.                    |
 |                                                                     |
 |    pOutputDataLength - on input specifies the length of the         |
 |                        pOutputData buffer and must be as large as   |
 |                        dataLength. On output it contains the        |
 |                        actual byte length of the data returned in   |
 |                        pOutputData.                                 |
 |                                                                     |
 |    pOutputData - pointer to the buffer to contain the resulting     |
 |                  encrypted data.                                    |
 |                                                                     |
 |                                                                     |
 | Process:                                                            |
 |                                                                     |
 |    1.  Ensure inputdatalength is a multiple of 8; if not            |
 |        return an error.                                             |
 |                                                                     |
 |    2.  Copy input key and iv to temp_key and temp_iv                |
 |                                                                     |
 |    3.  Invoke des_set_key_unchecked(pKeyDes, schedule) three times  |
 |          des_set_key_unchecked(pKeyDes, ks[0])                      |
 |          des_set_key_unchecked(pKeyDes+8, ks[1])                    |
 |          des_set_key_unchecked(pKeyDes+16, ks[2])                   |
 |                                                                     |
 |    4.  If mode is MODE_DES_CBC                                      |
 |          Invoke des_ede3_cbc_encrypt(pInputData,                    |
 |                                      pOutputData,                   |
 |                                      (long) dataLength,             |
 |                                      ks[0],ks[1],ks[2],             |
 |                                      &temp_iv,                      |
 |                                      enc)                           |
 |        Otherwise:                                                   |
 |          8 bytes at a time:                                         |
 |            Copy InputData into Temp_input, advancing input ptr      |
 |            Set output pointer to beginning of output buffer         |
 |            Invoke des_ecb3_encrypt(pTemp_input,                     |
 |                                    pTemp_ouput,                     |
 |                                    ks[0],ks[1],ks[2],               |
 |                                    enc)                             |
 |            Copy Temp_output to output buffer,                       |
 |            advancing output ptr                                     |
 |                                                                     |
 |    5.  Set outputdata length                                        |
 |                                                                     |
 | Return code: Zero if successful                                     |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
icaTDesSW(unsigned int            mode,
	  unsigned int            dataLength,
	  unsigned int            enc,
	  unsigned char          *pInputData,
	  ICA_DES_VECTOR         *pIv,
	  ICA_KEY_DES_TRIPLE     *pKeyDes,
	  unsigned int           *pOutputDataLength,
	  unsigned char          *pOutputData)
{
  int i, rc = 0;
  des_key_schedule ks[3];
  const_des_cblock temp_key;
  des_cblock temp_iv;
  const_des_cblock temp_input;
  des_cblock temp_output;
  unsigned char *keyp;

  if (dataLength % 8) {
    *pOutputDataLength = 0;
    return HDDInvalidParm;
  }

  keyp = (unsigned char *)pKeyDes;
  for (i = 0;i < 3; i++) {
    memcpy (&temp_key, keyp, 8);
    des_set_key_unchecked(&temp_key, ks[i]);
    keyp += 8;
  }

  if ( mode == MODE_DES_CBC ) {
    memcpy(&temp_iv, pIv, 8);
    des_ede3_cbc_encrypt((const unsigned char *)pInputData,
			 pOutputData,
			 (long)dataLength,
			 ks[0], ks[1], ks[2],
			 &temp_iv,
			 enc );
  }
  else {
    for (i = 0; i < dataLength; i += 8) {
      memcpy(&temp_input, pInputData + i, 8);
      des_ecb3_encrypt(&temp_input,
                       &temp_output,
		       ks[0], ks[1], ks[2],
		       enc );
      memcpy(pOutputData + i, temp_output, 8);
    }
  }

  *pOutputDataLength = dataLength;
  return (rc);
} // end icaTDesSW

/*---------------------------------------------------------------------*
 |                                                                     |
 | ModExpoSW                                                           |
 |                                                                     |
 | Purpose: Perform a RSA encryption/decryption operation using a      |
 |          key in modulus/exponent form, in software                  |
 |                                                                     |
 | Parameters:                                                         |
 |                                                                     |
 |    arglength - the byte length of the input data                    |
 |                                                                     |
 |    arg - pointer to input data                                      |
 |                                                                     |
 |    explength - the byte length of the exponent                      |
 |                                                                     |
 |    exp - pointer to the exponent                                    |
 |                                                                     |
 |    modlength - the byte length of the modulus                       |
 |                                                                     |
 |    mod - pointer to the modulus                                     |
 |                                                                     |
 |    reslengthp - on input it points to the byte length of            |
 |                 the output buffer.  On output it points to          |
 |                 the actual byte length of the outputdata            |
 |                                                                     |
 |    res - pointer to the output buffer                               |
 |                                                                     |
 |    ctx - pointer to a BN_CTX                                        |
 |                                                                     |
 | Return codes: Zero if successful                                    |
 |               BN error code if unsuccessful                         |
 | Process:                                                            |
 |      1) Call BN_new for the argument, exponent, modulus and         |
 |         result BN's                                                 |
 |      2) Convert the argument, exponent and modulus to BN's using    |
 |         BN_bin2bn;                                                  |
 |      3) Call BN_mod_expo                                            |
 |      4) Convert the result from a BN to a string using BN_bn2bin    |
 |      5) Call BN_free for the argument, exponent, modulus and        |
 |         result BN's                                                 |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
ModExpoSW(int arglength, char * arg,
	  int explength, char * exp,
	  int modlength, char * mod,
	  int *reslengthp, char * res, BN_CTX * ctx)
{
  int rc = 0;
  int ln = 0;
  int pad = 0;
  BIGNUM  *Barg = NULL;
  BIGNUM  *Bexp = NULL;
  BIGNUM  *Bmod = NULL;
  BIGNUM  *Bres = NULL;
  BN_CTX  *modExpoCtx = NULL;
  int      modExpoRc = 1;

  BN_CTX_start(ctx);

  Barg = BN_CTX_get(ctx);
  Bexp = BN_CTX_get(ctx);
  Bmod = BN_CTX_get(ctx);
  if ((Bres = BN_CTX_get(ctx)) == NULL) {
    rc = ENOMEM;
    goto cleanup;
  }

  Barg = BN_bin2bn(arg, arglength, Barg);
  Bexp = BN_bin2bn(exp, explength, Bexp);
  Bmod = BN_bin2bn(mod, modlength, Bmod);

  // Evidently BN_mod_exp gets a *lot* of temp BN's, so it
  // needs a context all its own.
  if ((modExpoCtx = BN_CTX_new()) == NULL) {
    goto err;
  }
  modExpoRc = BN_mod_exp(Bres, Barg, Bexp, Bmod, modExpoCtx);
  BN_CTX_free(modExpoCtx);

  if(!(modExpoRc)) {
    goto err;
  }

  if ((ln=BN_num_bytes(Bres)) > *reslengthp) {
    rc = HDDInvalidParm;
    goto cleanup;
  }

  if (ln)
    pad = *reslengthp - ln;

  ln = BN_bn2bin(Bres, res + pad);

  if (pad)
    memset(res,0,pad);

  goto cleanup;

err:
  rc = HDDInvalidParm;

cleanup:
  BN_CTX_end(ctx);

  return (rc);
} // end ModExpoSW

/*---------------------------------------------------------------------*
 |                                                                     |
 | ModMulSW                                                            |
 |                                                                     |
 | Purpose: Perform a multiprecision modular multiplication using a    |
 |          multiplicand, multiplier and modulus                       |
 |                                                                     |
 | Parameters:                                                         |
 |                                                                     |
 |    fc1length - the byte length of the multiplicand                  |
 |                                                                     |
 |    fc1 - pointer to multiplicand                                    |
 |                                                                     |
 |    fc2length - the byte length of the multiplier                    |
 |                                                                     |
 |    fc2 - pointer to the multiplier                                  |
 |                                                                     |
 |    modlength - the byte length of the modulus                       |
 |                                                                     |
 |    mod - pointer to the modulus                                     |
 |                                                                     |
 |    reslengthp - on input it points to the byte length of            |
 |                 the output buffer.  On output it points to          |
 |                 the actual byte length of the outputdata            |
 |                                                                     |
 |    res - pointer to the output buffer                               |
 |                                                                     |
 |    ctx - pointer to a BN_CTX                                        |
 |                                                                     |
 | Return codes: Zero if successful                                    |
 |               BN error code if unsuccessful                         |
 | Process:                                                            |
 |      1) Call BN_CTX_get for the multiplicand, multiplier,           |
 |         modulus and result BN's                                     |
 |      2) Convert the multiplicand, multipler and modulus to BN's     |
 |         using BN_bin2bn                                             |
 |      3) Call BN_mod_mul                                             |
 |      4) Convert the result from a BN to a string using BN_bn2bin    |
 |      5) Call BN_free for the multiplicand, multipler, modulus and   |
 |         result BN's                                                 |
 |      6) Right-justify the result in the original output field       |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
ModMulSW(int fc1length, char * fc1,
         int fc2length, char * fc2,
         int modlength, char * mod,
         int *reslengthp, char * res, BN_CTX * ctx)
{
  int rc = 0;
  int ln = 0;
  int pad = 0;
  BIGNUM  *Bfc1 = NULL;
  BIGNUM  *Bfc2 = NULL;
  BIGNUM  *Bmod = NULL;
  BIGNUM  *Bres = NULL;

  BN_CTX_start(ctx);

  Bfc1 = BN_CTX_get(ctx);
  Bfc2 = BN_CTX_get(ctx);
  Bmod = BN_CTX_get(ctx);
  if ((Bres = BN_CTX_get(ctx)) == NULL) {
    rc = -ENOMEM;
    goto cleanup;
  }

  Bfc1 = BN_bin2bn(fc1, fc1length, Bfc1);
  Bfc2 = BN_bin2bn(fc2, fc2length, Bfc2);
  Bmod = BN_bin2bn(mod, modlength, Bmod);

  if(!(BN_mod_mul(Bres, Bfc1, Bfc2, Bmod, ctx))) {
    goto err;
  }

  if ((ln=BN_num_bytes(Bres)) > *reslengthp) {
    rc = HDDInvalidParm;
    goto cleanup;
  }

  if (ln)
    pad = *reslengthp - ln;

  ln = BN_bn2bin(Bres, res + pad);

  if (pad)
    memset(res,0,pad);

  goto cleanup;

err:
  rc = HDDInvalidParm;

cleanup:
  BN_CTX_end(ctx);

  return (rc);
} // end ModMulSW

/*---------------------------------------------------------------------*
 |                                                                     |
 | ModSW                                                               |
 |                                                                     |
 | Purpose: Perform a 'residue modulo' operation using an argument     |
 |          and a modulus                                              |
 |                                                                     |
 | Parameters:                                                         |
 |                                                                     |
 |    arglength - the byte length of the input data                    |
 |                                                                     |
 |    arg - pointer to input data                                      |
 |                                                                     |
 |    modlength - the byte length of the modulus                       |
 |                                                                     |
 |    mod - pointer to the modulus                                     |
 |                                                                     |
 |    reslengthp - on input it points to the byte length of            |
 |                 the output buffer.  On output it points to          |
 |                 the actual byte length of the outputdata            |
 |                                                                     |
 |    res - pointer to the output buffer                               |
 |                                                                     |
 |    ctx - pointer to a BN_CTX                                        |
 |                                                                     |
 | Return codes: Zero if successful                                    |
 |               BN error code if unsuccessful                         |
 | Process:                                                            |
 |      1) Call BN_CTX_get for the argument, modulus and result BN's   |
 |      2) Convert the argument and modulus to BN's using BN_bin2bn    |
 |      3) Call BN_mod                                                 |
 |      4) Convert the result from a BN to a string using BN_bn2bin    |
 |      5) Call BN_free for the argument, modulus and result BN's      |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
ModSW(int arglength, char * arg,
      int modlength, char * mod,
      int *reslengthp, char * res, BN_CTX * ctx)
{
  int rc = 0;
  int ln = 0;
  int pad = 0;
  BIGNUM  *Barg = NULL;
  BIGNUM  *Bmod = NULL;
  BIGNUM  *Bres = NULL;

  BN_CTX_start(ctx);

  Barg = BN_CTX_get(ctx);
  Bmod = BN_CTX_get(ctx);
  if ((Bres = BN_CTX_get(ctx)) == NULL) {
    rc = -ENOMEM;
    goto cleanup;
  }

  Barg = BN_bin2bn(arg, arglength, Barg);
  Bmod = BN_bin2bn(mod, modlength, Bmod);

  if(!(BN_mod(Bres, Barg, Bmod, ctx))) {
    goto err;
  }

  if ((ln=BN_num_bytes(Bres)) > *reslengthp) {
    rc = HDDInvalidParm;
    goto cleanup;
  }

  if (ln)
    pad = *reslengthp - ln;

  ln = BN_bn2bin(Bres, res + pad);

  if (pad)
    memset(res,0,pad);

  goto cleanup;

err:
  rc = HDDInvalidParm;

cleanup:
  BN_CTX_end(ctx);

  return (rc);
} // end ModSW

/*---------------------------------------------------------------------*
 |                                                                     |
 | ModSubSW                                                            |
 |                                                                     |
 | Purpose: Perform a multiprecision subtraction modulo a modulus      |
 |          using a minuend, subtrahend and modulus                    |
 |                                                                     |
 | Parameters:                                                         |
 |                                                                     |
 |    minlength - the byte length of the minuend                       |
 |                                                                     |
 |    min - pointer to minuend                                         |
 |                                                                     |
 |    sublength - the byte length of the subtrahend                    |
 |                                                                     |
 |    sub - pointer to the subtrahend                                  |
 |                                                                     |
 |    modlength - the byte length of the modulus                       |
 |                                                                     |
 |    mod - the modulus                                                |
 |                                                                     |
 |    reslengthp - on input it points to the byte length of            |
 |                 the output buffer.  On output it points to          |
 |                 the actual byte length of the outputdata            |
 |                                                                     |
 |    res - pointer to the output buffer                               |
 |                                                                     |
 |    ctx - pointer to a BN_CTX                                        |
 |                                                                     |
 | Return codes: Zero if successful                                    |
 |               BN error code if unsuccessful                         |
 | Process:                                                            |
 |      1) If the subtrahend exceeds the minuend, use AddSW to         |
 |         add the modulus to the minuend                              |
 |      2) Call BN_CTX_get for the minuend, subtrahend & result BN's   |
 |      3) Convert the minuend and subtrahend BN's using BN_bin2bn     |
 |      4) Call BN_sub                                                 |
 |      5) Convert the result from a BN to a string using BN_bn2bin    |
 |      6) Call BN_free for the minuend, subtrahend and result BN's    |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
ModSubSW(int minlength, char * minu,
         int sublength, char * sub,
         int modlength, char * mod,
         int *reslengthp, char * res, BN_CTX * ctx)
{
  int rc = 0;
  int ln = 0;
  int pad = 0;

  int sizMin, sizSub, sizDif;

  BIGNUM  *Bmin = NULL;
  BIGNUM  *Bsub = NULL;
  BIGNUM  *Bmod = NULL;
  BIGNUM  *Bres = NULL;

  BN_CTX_start(ctx);

  Bmin = BN_CTX_get(ctx);
  Bsub = BN_CTX_get(ctx);
  Bmod = BN_CTX_get(ctx);
  if ((Bres = BN_CTX_get(ctx)) == NULL) {
    rc = -ENOMEM;
    goto cleanup;
  }

  Bmin = BN_bin2bn(minu, minlength, Bmin);
  Bsub = BN_bin2bn(sub, sublength, Bsub);
  Bmod = BN_bin2bn(mod, modlength, Bmod);

  sizMin = BN_num_bytes(Bmin);
  sizSub = BN_num_bytes(Bsub);

  /* if sub == min, the result is zero, but it's an error */
  if (sizSub == sizMin) {
    sizDif = memcmp(sub, minu, sublength);
    if (sizDif == 0) {
      memset(res, 0, *reslengthp);
      rc = -1;
      goto cleanup;
    }
  }

  /* if sub < min, the result is just min - sub */
  if ((sizSub < sizMin) || ((sizSub == sizMin) && (sizDif < 0))) {
    if (!(BN_sub(Bres, Bmin, Bsub))) {
      goto err;
    }
  }
  else { /* sub > min, so the result is (min + mod) - sub */
    if (!(BN_add(Bres, Bmin, Bmod))) {
      goto err;
    }
    if (!(BN_sub(Bres, Bres, Bsub))) {
      goto err;
    }
  }

  if ((ln=BN_num_bytes(Bres)) > *reslengthp) {
    rc = HDDInvalidParm;
    goto cleanup;
  }

  if (ln)
    pad = *reslengthp - ln;

  ln = BN_bn2bin(Bres, res + pad);

  if (pad)
    memset(res,0,pad);

  goto cleanup;

err:
  rc = HDDInvalidParm;

cleanup:
  BN_CTX_end(ctx);

  return (rc);
} // end ModSubSW

/*---------------------------------------------------------------------*
 |                                                                     |
 | AddSW                                                               |
 |                                                                     |
 | Purpose: Perform a multiprecision addition using an augend and      |
 |          addend                                                     |
 |                                                                     |
 | Parameters:                                                         |
 |                                                                     |
 |    auglength - the byte length of the augend                        |
 |                                                                     |
 |    aug - pointer to augend                                          |
 |                                                                     |
 |    addlength - the byte length of the addend                        |
 |                                                                     |
 |    add - pointer to the addend                                      |
 |                                                                     |
 |    reslengthp - on input it points to the byte length of            |
 |                 the output buffer.  On output it points to          |
 |                 the actual byte length of the outputdata            |
 |                                                                     |
 |    res - pointer to the output buffer                               |
 |                                                                     |
 |    ctx - pointer to a BN_CTX                                        |
 |                                                                     |
 | Return codes: Zero if successful                                    |
 |               BN error code if unsuccessful                         |
 | Process:                                                            |
 |      1) Call BN_CTX_get for the augend, addend and result BN's      |
 |      2) Convert the augend and addend BN's using BN_bin2bn          |
 |      3) Call BN_add                                                 |
 |      4) Convert the result from a BN to a string using BN_bn2bin    |
 |      5) Call BN_free for the augend, addend and result BN's         |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
AddSW(int auglength, char * aug,
      int addlength, char * add,
      int *reslengthp, char * res, BN_CTX * ctx)
{
  int rc = 0;
  int ln = 0;
  int pad = 0;
  BIGNUM  *Baug = NULL;
  BIGNUM  *Badd = NULL;
  BIGNUM  *Bres = NULL;

  BN_CTX_start(ctx);

  Baug = BN_CTX_get(ctx);
  Badd = BN_CTX_get(ctx);
  if ((Bres = BN_CTX_get(ctx)) == NULL) {
    rc = -ENOMEM;
    goto cleanup;
  }

  Baug = BN_bin2bn(aug, auglength, Baug);
  Badd = BN_bin2bn(add, addlength, Badd);

  if(!(BN_add(Bres, Baug, Badd))) {
    goto err;
  }

  if ((ln=BN_num_bytes(Bres)) > *reslengthp) {
    rc = HDDInvalidParm;
    goto cleanup;
  }

  if (ln)
    pad = *reslengthp - ln;

  ln = BN_bn2bin(Bres, res + pad);

  if (pad)
    memset(res,0,pad);

  goto cleanup;

err:
  rc = HDDInvalidParm;

cleanup:
  BN_CTX_end(ctx);

  return (rc);
} // end AddSW

/*---------------------------------------------------------------------*
 |                                                                     |
 | MulSW                                                               |
 |                                                                     |
 | Purpose: Perform a multiprecision multiply using a multiplicand and |
 |          multiplier                                                 |
 |                                                                     |
 | Parameters:                                                         |
 |                                                                     |
 |    fc1length - the byte length of the multiplicand                  |
 |                                                                     |
 |    fc1 - pointer to multiplicand                                    |
 |                                                                     |
 |    fc2length - the byte length of the multiplier                    |
 |                                                                     |
 |    fc2 - pointer to the multiplier                                  |
 |                                                                     |
 |    reslengthp - on input it points to the byte length of            |
 |                 the output buffer.  On output it points to          |
 |                 the actual byte length of the outputdata            |
 |                                                                     |
 |    res - pointer to the output buffer                               |
 |                                                                     |
 |    ctx - pointer to a BN_CTX                                        |
 |                                                                     |
 | Return codes: Zero if successful                                    |
 |               BN error code if unsuccessful                         |
 | Process:                                                            |
 |      1) Call BN_CTX_get for three BN's                              |
 |      2) Convert the multiplicand and multiplier using BN_bin2bn     |
 |      3) Call BN_mul                                                 |
 |      4) Convert the result from a BN to a string using BN_bn2bin    |
 |      5) Call BN_free for the three BN's                             |
 |                                                                     |
 *---------------------------------------------------------------------*/
unsigned int
MulSW(int fc1length, char * fc1,
      int fc2length, char * fc2,
      int *reslengthp, char * res, BN_CTX * ctx)
{
  int rc = 0;
  int ln = 0;
  int pad = 0;
  BIGNUM  *Bfc1 = NULL;
  BIGNUM  *Bfc2 = NULL;
  BIGNUM  *Bres = NULL;

  BN_CTX_start(ctx);

  Bfc1 = BN_CTX_get(ctx);
  Bfc2 = BN_CTX_get(ctx);
  if ((Bres = BN_CTX_get(ctx)) == NULL) {
    rc = -ENOMEM;
    goto cleanup;
  }

  Bfc1 = BN_bin2bn(fc1, fc1length, Bfc1);
  Bfc2 = BN_bin2bn(fc2, fc2length, Bfc2);

  if(!(BN_mul(Bres, Bfc1, Bfc2, ctx))) {
    goto err;
  }

  if ((ln=BN_num_bytes(Bres)) > *reslengthp) {
    rc = HDDInvalidParm;
    goto cleanup;
  }

  if (ln)
    pad = *reslengthp - ln;

  ln = BN_bn2bin(Bres, res + pad);

  if (pad)
    memset(res,0,pad);

  goto cleanup;

err:
  rc = HDDInvalidParm;

cleanup:
  BN_CTX_end(ctx);

  return (rc);
} // end MulSW

/*---------------------------------------------------------------------*
 |                                                                     |
 | icaSha1SW                                                           |
 |                                                                     |
 | Purpose: Compute a digest using the sha1 functions embedded in      |
 |          libica.                                                    |
 |                                                                     |
 | Parameters:                                                         |
 |    arg - pointer to an ica_sha1_t containing:                       |
 |                                                                     |
 |          a.  inputdata -- address of input                          |
 |          b.  intputdatalength -- byte length of input               |
 |          c.  outputdata -- address of a buffer for the output hash  |
 |          d.  initialh -- address of an input hash                   |
 |                                                                     |
 |    rule - an integer indicating the sha message part:               |
 |          0 -- ONLY                                                  |
 |          1 -- FIRST                                                 |
 |          2 -- MIDDLE                                                |
 |          3 -- FINAL                                                 |
 |                                                                     |
 |    *pSum - a running total of input bytes that have been hashed     |
 |                                                                     |
 |    outputh - address of an output hash                              |
 |                                                                     |
 | Process:                                                            |
 |                                                                     |
 |    1.  Declare a SHA_CTX                                            |
 |                                                                     |
 |    2.  Pre_process:                                                 |
 |                                                                     |
 |        If rule is FIRST or ONLY, call SHA_Init                      |
 |                                                                     |
 |        Note:  If this is part FIRST or MIDDLE, the input data       |
 |               are assumed to be a multiple of 64-bytes long         |
 |                                                                     |
 |        If rule is MIDDLE, reconstruct the SHA_CTX with:             |
 |               zeroes in the input buffer                            |
 |               zero in the input buffer length field                 |
 |               *pSum in the runningtotal                             |
 |               initialh in the hash buffer                           |
 |                                                                     |
 |        if rule is FINAL, reconstruct the SHA_CTX with:              |
 |               inputdata in the input buffer                         |
 |               inputdatalength in the input buffer length field      |
 |               *pSum in the running total                            |
 |               initialh in the hash buffer                           |
 |                                                                     |
 |        if rule is ONLY and inputdatalength < 64, construct SHA_CTX: |
 |               inputdata in the input buffer                         |
 |               inputdatalength in the input buffer length field      |
 |               Leave the running total and hash buffer intact in the |
 |                         newly initialized SHA_CTX                   |
 |                                                                     |
 |    3.  Do SHA_Update:                                               |
 |                                                                     |
 |        If rule is FIRST, MIDDLE, or ONLY with length >= 64:         |
 |               Call SHA_Update                                       |
 |                                                                     |
 |        If rule is FIRST or MIDDLE:                                  |
 |               Return the output hash and running total to caller    |
 |                                                                     |
 |    4.  Do SHA_Final                                                 |
 |                                                                     |
 |        (rule is FINAL or ONLY)                                      |
 |               Call SHA_Final                                        |
 |               Return the output hash and running total to caller    |
 |                                                                     |
 | Return code: Zero if successful                                     |
 |                                                                     |
 *---------------------------------------------------------------------*/
int
icaSha1SW(ica_sha1_t * arg, unsigned int rule,
		unsigned long long *pSum, unsigned char * outputh)
{
	int rv = 0;
	SHA_CTX ctx;

	switch (rule) {
		case SHA_MSG_PART_ONLY:
			SHAA_Init(&ctx);
			SHAA_Update(&ctx, arg->inputdata,
					arg->inputdatalength);
			SHAA_Final(&ctx, outputh);
			break;
		case SHA_MSG_PART_FIRST:
			SHAA_Init(&ctx);
			SHAA_Update(&ctx,arg->inputdata,arg->inputdatalength);
			memcpy((unsigned char *)pSum,
			       (unsigned char *)&ctx.Lhigh,
				sizeof(long long));
			memcpy(outputh,
			       (unsigned char *)&ctx.h0,
				ICA_SHA_DATALENGTH);
			break;
		case SHA_MSG_PART_MIDDLE:
			memset((unsigned char *)&ctx, 0, sizeof(ctx));
			memcpy((unsigned char *)&ctx.Lhigh,
				(unsigned char *)pSum,
				sizeof(long long));
			memcpy((unsigned char *)&ctx.h0,
				(unsigned char *)arg->initialh,
				ICA_SHA_DATALENGTH);
			SHAA_Update(&ctx,arg->inputdata,arg->inputdatalength);
			memcpy((unsigned char *)pSum,
			       (unsigned char *)&ctx.Lhigh,
				sizeof(long long));
			memcpy(outputh,
			       (unsigned char *)&ctx.h0,
				ICA_SHA_DATALENGTH);
			break;
		case SHA_MSG_PART_FINAL:
			if (arg->inputdatalength > 63) {
				ctx.bytes_in_buffer = 0;
				memset((unsigned char *)ctx.byte_buffer,0,
					sizeof(ctx.byte_buffer));
				memcpy((unsigned char *)&ctx.Lhigh,
					(unsigned char *)pSum,
					sizeof(long long));
				memcpy((unsigned char *)&ctx.h0,
					(unsigned char *)arg->initialh,
					ICA_SHA_DATALENGTH);
				SHAA_Update(&ctx,arg->inputdata,
						arg->inputdatalength);
			} else {
	                        ctx.bytes_in_buffer = arg->inputdatalength;
        	                memcpy ((unsigned char *)ctx.byte_buffer,
                	                (unsigned char *)arg->inputdata,
                        	         arg->inputdatalength);
				memcpy((unsigned char *)&ctx.h0,
					(unsigned char *)arg->initialh,
					ICA_SHA_DATALENGTH);
                        	*pSum+=arg->inputdatalength;
				memcpy((unsigned char *)&ctx.Lhigh,
					(unsigned char *)pSum,
					sizeof(long long));
			}
			SHAA_Final(&ctx, outputh);
		default:
			break;
	}

	return rv;
} // end icaSha1SW

/*-------------------------------------------------------------------*/
/* sha                                                               */
/*-------------------------------------------------------------------*/
int zSha1(ica_sha1_t * arg, unsigned int rule, unsigned long long *pSum)
{
	int rv = 0;
	ica_sha1_t * pSha = arg;
	unsigned long long sum;
	unsigned long remnant = 0;
	int complete_blocks_length = 0;
	unsigned char shabuff[LENGTH_SHA_CONTEXT];
	struct sigaction new, old;
	sigset_t newset, oldset;

	// If this is a FIRST or ONLY call, supply the standard SHA1
	// initial vector.  Otherwise, use the input chaining vector
	if (rule == SHA_MSG_PART_ONLY || rule == SHA_MSG_PART_FIRST) {
		memcpy (shabuff, SHACONST, ICA_SHA_DATALENGTH);
		sum = 0LL;
	} else {
		// Copy the caller's chaining vector to local storage
		memcpy(shabuff, (void *)pSha->initialh, ICA_SHA_DATALENGTH);
		sum = *pSum;
	}

	// Compute the length of any incomplete block
	if (pSha->inputdatalength) {
		remnant = pSha->inputdatalength % ICA_SHA_BLOCKLENGTH;
		complete_blocks_length = pSha->inputdatalength - remnant;
	}

	// If this is a FIRST or MIDDLE call, the remnant must be zero.
	if ((rule == SHA_MSG_PART_FIRST || rule == SHA_MSG_PART_MIDDLE) &&
								(remnant != 0))
		return HDDInvalidParm;

	if (extra_sigill_checks) {
		sigemptyset(&newset);
		sigaddset(&newset, SIGILL);
		sigprocmask(SIG_UNBLOCK, &newset, &oldset);
		new.sa_handler = (void *) sigill_handler;
		new.sa_flags = 0;
		sigaction(SIGILL, &new, &old);

		if (setjmp(envq) != 0) {
			sha1_switch = 0;
			sigaction(SIGILL, &old, NULL);
			sigprocmask(SIG_SETMASK, &oldset, NULL);
			return EXCEPTION_RV;
		}
	}

	// If there are any complete blocks:
	if (complete_blocks_length) {
		// Digest the complete blocks and recompute the
		// bitlength
		if ((rv = KIMD(shabuff,
				pSha->inputdata,
				complete_blocks_length)) == 0) {
			sum += (long long) complete_blocks_length;
		} // end if rv 0
	} // end if there are complete blocks

	if (rule == SHA_MSG_PART_ONLY || rule == SHA_MSG_PART_FINAL) {
		// Digest the remnant and compute the bit length
		sum = 8*(sum + (long long) remnant);
		memcpy(shabuff+ICA_SHA_DATALENGTH,
		       (unsigned char *)&sum,
		       sizeof(sum));
		rv = KLMD(shabuff,
			pSha->inputdata+complete_blocks_length,
			remnant);
	} // end if ONLY or FINAL

	if (extra_sigill_checks) {
		sigaction(SIGILL, &old, NULL);
		sigprocmask(SIG_SETMASK, &oldset, NULL);
	}

	if(rv == 0) {
		// Copy the caller's output
		memcpy((void *)pSha->outputdata, shabuff,
			ICA_SHA_DATALENGTH);
		// If appropriate, copy the caller's
		// chaining vector and running total
		if (rule != SHA_MSG_PART_FINAL &&
				rule != SHA_MSG_PART_ONLY) {
			memcpy((void *)pSha->initialh, shabuff,
				ICA_SHA_DATALENGTH);
			*pSum = sum;
		}
	} // end switch(rv)

	return rv;

} // end zSha1

/*-------------------------------------------------------------------*/
/* des                                                               */
/*-------------------------------------------------------------------*/
int zDes(ica_des_t * arg, unsigned int keysLen)
{
	struct sigaction new, old;
	sigset_t newset, oldset;
	int rv = 0;
	unsigned long function_code;
	ica_des_t * pDes = arg;
#ifndef _SCAFF
        unsigned char keybuff
			[sizeof(ICA_DES_VECTOR)+sizeof(ICA_KEY_DES_TRIPLE)];
#else
	unsigned char * keybuff;
	keybuff = (unsigned char *)malloc(sizeof(ICA_DES_VECTOR)+
					  sizeof(ICA_KEY_DES_TRIPLE));
#endif  // _SCAFF


	// Check input data length
	if (pDes->inputdatalength & 0x07) {
		return HDDInvalidParm;
	}

	switch(pDes->mode){
		case DEVICA_MODE_DES_CBC:

			// Copy caller's chaining vector and keys to local stge
			memcpy(keybuff, (void *)pDes->iv, sizeof(*(pDes->iv)));
			memcpy(keybuff+sizeof(*(pDes->iv)),pDes->keys,keysLen);
			break;

		case DEVICA_MODE_DES_ECB:

			// Copy the caller's keys to local storage
			memcpy(keybuff, pDes->keys, keysLen);
			break;

		default:
			return HDDInvalidParm;
			break;
	} // end switch mode

	// Compute the function code
	function_code = keysLen/8;
	switch(pDes->direction) {
		case DEVICA_DIR_DES_DECRYPT:
			function_code += 0x80;
			break;
		case DEVICA_DIR_DES_ENCRYPT:
			break;
		default:
			return HDDInvalidParm;
			break;
	}

	if (extra_sigill_checks) {
		sigemptyset(&newset);
		sigaddset(&newset, SIGILL);
		sigprocmask(SIG_UNBLOCK, &newset, &oldset);
		new.sa_handler = (void *) sigill_handler;
		new.sa_flags = 0;
		sigaction(SIGILL, &new, &old);
		if (setjmp(envq) != 0) {
			des_switch = 0;
			sigaction(SIGILL, &old, NULL);
			sigprocmask(SIG_SETMASK, &oldset, NULL);
			return EXCEPTION_RV;
		}
	}

	if (pDes->mode == DEVICA_MODE_DES_CBC) {
		rv = KMC(function_code,
			 keybuff,
			 pDes->outputdata,
			 pDes->inputdata,
			 pDes->inputdatalength);
	} else {
		rv = KM(function_code,
			keybuff,
			pDes->outputdata,
			pDes->inputdata,
			pDes->inputdatalength);
	}

	if (extra_sigill_checks) {
		sigaction(SIGILL, &old, NULL);
		sigprocmask(SIG_SETMASK, &oldset, NULL);
	}

	return rv;
} // end zDes
#endif // end if _LINUX_S390_

